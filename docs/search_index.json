[["basic-malaria-models.html", "2 Basic Malaria Models", " 2 Basic Malaria Models Basic malaria models as deterministic or stochastic systems of difference or differential equations Ross was interested in planning for malaria control. Given his interests in measuring malaria, he immediately noticed the importance of the fact that malaria prevalence differed from place to place. Ross wanted to understand why, so he developed mathematical models of malaria as a way of understanding the factors affecting the prevalence of malaria infection among humans in a population. Malaria infections in the two populations are connected through blood feeding, so malaria transmission works as an integrated system. The process looks something like the following diagram. This graph is the basis for causal theory for malaria, but students of causation will note that this is not an acyclic graph. If we applied the logic more generally, no graph describing any organisms life cycle would be causal, and yet life is undoubtedly the cause of life. The missing element is time: a life-cycle graph would be directed and acyclic if it had an arrow that traced life giving rise to new life across generations. To understand this diagram as causal, we must thus imagine that it describes a dynamical process describing changes in populations: infected mosquitoes today are biting and infecting humans tomorrow; and infectious humans today are causing infections in mosquitoes tomorrow when they take a blood meal. Seen in this way, we can begin to develop a causal theory for malaria in populations. How does malaria persist in a population? It persists through the transmission of parasites among hosts during blood feeding. What factors determine prevalence? It is a balance between the gain and loss of infection. To develop a mathematical model, Ross believed that it was possible to write down a priori – or in other words, to formulate mathematical models using quantitative logic – a description of the process. To write down the model, we must make some assumptions about the process. We begin with an abstract concept of place: here. We imagine populations here comprised of individual mosquitoes and individual humans, and we are interested in computing the fraction of humans and mosquitoes that is infected. Since infections don’t last forever, the prevalence of infection in mosquitoes and mosquitoes reflects a balance between infections acquired through parasite transmission and the natural loss of infection and host mortality. In many places, this balance is always shifting as mosquito populations fluctuate. He assumed that transmission by mosquitoes was constant over time, and he focused on local transmission, ignoring exposure elsewhere (e.g. through travel). This model thus ignores many factors that would be important for planning for control; Ross was pioneering a new approach so the models were rudimentary. Mosquitoes lived short lives, so the loss of parasites in mosquitoes was mainly caused by mosquito mortality: \\[ \\mbox{MOSQUITOES} \\\\ \\; \\\\ \\left[ \\begin{array}{rcl} \\mbox{Infected Tomorrow} &amp;=&amp; \\mbox{Infected Today} \\\\ &amp;-&amp;\\mbox{Infected: Died}\\\\ &amp;+&amp;\\mbox{Uninfected: Got Infected}\\\\ \\end{array} \\right] \\] This description of a process ignores the loss of infection in mosquitoes, and changes in mosquito populations through migration. It ignored the lag between the point in time when a mosquito gets infected and when it becomes infectious. This basic description of the process does not explicitly address the fact that each dying infected mosquito must get replaced by an uninfected mosquito through emergence from aquatic habitats, or else the mosquito population would be declining over time. The process emphasizes malaria transmission dynamics, so mosquito ecology is almost invisible. Humans live long lives, so parasite loss occurred through the natural clearance of infections. \\[ \\mbox{HUMANS} \\\\ \\; \\\\ \\left[ \\begin{array}{rcl} \\mbox{Infected Tomorrow} &amp;=&amp; \\mbox{Infected Today} \\;\\; \\\\ &amp;-&amp; \\mbox{Infected: Cleared Infection}\\\\ &amp;+&amp; \\mbox{Uninfected: Got Infected}\\\\ \\end{array} \\right] \\] This description of the process thus ignores human demography, including births, deaths, and migration. The model also ignores a large number of other factors, including superinfection, the complex time course of an infection, immunity, and treatment with anti-malarial drugs. (In Ross’s day, quinine was expensive and difficult to obtain, but it was sometimes used.) To describe malaria transmission and factors that determine the prevalence of malaria in human populations over time, we will need to use mathematical models. In the sections that follow, we will thus translate the above basic description of a process into mathematical models formulated in discrete and continuous time, and as a deterministic or stochastic processes. In the following, we will write down several distinct sets of mathematical equations that follow the basic rules described above: In Section 2.1, we present two basic deterministic discrete-time systems. In Section 2.2, we present a deterministic continuous-time system; In Section 2.3, we present a stochastic discrete-time system; In Section 2.4, we present a stochastic process in continuous-time; As a reminder, we’re not trying to delve too deeply into malaria with the models in this chapter. Instead, we’re trying to establish a starting point for investigating malaria transmission dynamics. Our goals are thus to learn the basic elements of different kinds of models, and to develop some basic intuition about the different kinds of models that exist, and how we can think about models as approximations. Each model is implemented as R code1 Later, we will start using some R packages that were developed to support robust analytics for malaria policy. Later, we’ll worry about modifying the assumptions to ensure that we are dealing with the issues that matter for in malaria policy. In developing this book, we assumed the reader would be familiar with R and RStudio.↩︎ "],["dtsRoss.html", "2.1 Deterministic, Discrete Time", " 2.1 Deterministic, Discrete Time In this section, we present a very basic deterministic, discrete-time model. Because it is the first model we present, we will be very methodical about the presentation, including sections about computation, analysis, and model verification. We show that the first mdoel is numerically unstable in some cases, so we present another model that is numerically stable. 2.1.1 ross_dts_1 We will write down the equations last. First, we must describe the parts of a model, including the variables, initial conditions, and parameters. As we go, we will also write R code that implements the model and that solves it. In writing the code, we will adopt some conventions that we can use to help us write good code. Variables are quantities that describe the state of a system. These values change over time; they are the main quantities that we want to compute to understand how the system changes over time. In this model, the variables we compute are the fraction of humans and mosquitoes that are infected at each point in time. Since it is a discrete time system, the values of the variables are defined only at integer values of \\(t.\\) Let \\(t\\) represent time Let \\(x_t\\) be the fraction of people who are infected at time \\(t,\\) and \\(0 \\leq x_t \\leq 1.\\) Let \\(y_t\\) be the fraction of mosquitoes who are infected at time \\(t,\\) \\(0 \\leq y_t \\leq 1.\\) In this model, time is marching forward. We call it the independent variable. The other variables are computed with respect to time, so we call them dependent variables. Initial Conditions are the values of the variables at a point in time. Since the values of our variables in the next time step (at time \\(t+1\\)) depend on their values now (at time \\(t\\)), we can’t really compute anything specific unless we specify the values of the variables at one point in time. We call these values the initial conditions. What are the values of our variables at the beginning of our simulations (usually, at time \\(t=0\\))? We set these initial values to be small: # Initial Conditions at a point in time, as a Named Vector xy = c(t=0, x=0.01, y=0.001) This R object xy is a named vector. The names are invisible, but they attach if we use the function as.list() or data.frame(). When combined with the with() function, we can call them by name in context. with(as.list(xy), x) ## [1] 0.01 We adopt these conventions so that the R code closely resembles the equations. Parameters are quantities – rates, numbers, or probabilities – that describe some part of the process. Unlike variables, parameters are passed to the model. In the model we present, these parameters are constant. Since they are constant, we call this an autonomous system of equations. In other models, we could have parameter values that changes over time, so the system would be called non-autonomous. The parameters in this model help us to define changes in the fraction infected: the fraction of humans that clear an infection each day; the fraction of infected mosquitoes that die; and blood feeding and infection. Let \\(s\\) denote the fraction of people who clear infections after one day; \\(0 &lt; s &lt; 1.\\) Let \\(u\\) denote the fraction of mosquitoes who die in one day; \\(0 &lt; u &lt; 1.\\) Let \\(a\\) denote the fraction of mosquitoes who blood feed on a human in a day; \\(0 &lt; a &lt; 1.\\) Let \\(m\\) denote the number of mosquitoes per human; \\(m \\geq 0.\\) # The parameters, as a list ross_dts_par = list( s = 1/200, # The fraction of infections that clear each day u = 1/12, # The fraction of mosquitoes that die each day a = 1/4, # The fraction of mosquitoes that blood feed on a human each day m = 2 # The number of mosquitoes per human ) Equations describe dynamic changes in the variables over time. In this case, the process is described by a system of coupled difference equations. Finally, we put all this together into a mathematical statement that has translated the description of a process, that are describe the process. \\[\\begin{array}{rl} x_{t+1} &amp;= x_t - s x_t + m a y_t (1-x_t) \\\\ y_{t+1} &amp;= y_t - u y_t + a x_t (1 - y_t) \\\\ \\end{array}\\] We could rewrite the equations so that the left hand side is interpreted as the daily change in the values of the parameters, and the terms on the right hand side describes those changes: \\[ \\begin{array}{rl} x_{t+1} - x_t &amp;= - s x_t + m a y_t (1-x_t) \\\\ y_{t+1} - y_t &amp;= - u y_t + a x_t (1 - y_t) \\\\ \\end{array} \\] In this second formulation, there are are four terms on the right hand side: The fraction of humans who are infected is \\(x_t\\); a fraction \\(s\\) clear infections. The fraction of humans who are infected is \\(1-x_t\\); a fraction \\(m a y_t\\) gets infected. (If \\(may_t &gt;1,\\) the term does not make sense. In sub-section 2.1.9, below, we discuss this in greater depth.) The fraction of mosquitoes who are infected is \\(y_t\\); a fraction \\(u\\) die. The fraction of mosquitoes who are not infected is \\(1-y_t\\); a fraction \\(a x_t\\) gets infected. We write a function in R that computes and returns the updated values of the variables. Since we will be developing a lot of functions and models, we adopt a simple naming convention: since it was developed by Ross, we attach the stem ross; since this is a discrete time system, we attach the suffix dts; we might want to generate other variants, so we append a number. The function is thus called ross_dts_1. # INPUTS # xy - current variables, as a named vector # p - the parameters, as a list # # OUTPUTS # the updated values of the variables, as a named vector ross_dts_1 = function(xy, p){ with(as.list(xy), with(p,{ xn = x - s*x + m*a*y*(1-x) yn = y - u*y + a*x*(1-y) return(c(t=t+1, x=xn, y=yn)) }) ) } 2.1.2 Solving With the R code we developed, we can solve the equations, which involves computing the values of the variables iteratively. Since the values of the variables change, we initialize xy_t to store the values of computed variables over time. # xy_t stores the values of the variables xy_t = xy To iterate, we must take two steps: one to compute the values, and another to store the values: # Compute and store the values of the variables xy = ross_dts_1(xy, ross_dts_par) xy_t = rbind(xy_t, xy) Since we initialized the system at time \\(t=0,\\) the following computes the values of the parameters at time \\(t=1.\\) We can take a peak at the values we computed: # Print print(xy) ## t x y ## 1.000000000 0.010445000 0.003414167 We can iterate over many time steps, storing the values in columns: # Iterate to compute the values as they change over time for(t in 2:40){ xy = ross_dts_1(xy, ross_dts_par) xy_t = rbind(xy_t, xy) } We can look at the last few values, the values of \\(t,\\) \\(x\\) and \\(y\\) are stored in columns: print(tail(xy_t, 3)) ## t x y ## xy 38 0.9865573 0.7465869 ## xy 39 0.9866426 0.7468730 ## xy 40 0.9866975 0.7470700 2.1.3 Visualizing We can now plot out the values over the first 40 days. Since xy_t is a named list, we transform it and plot: with(data.frame(xy_t),{ plot(t, x, type = &quot;b&quot;, ylim = c(0,1), col = &quot;darkgreen&quot;, ylab = &quot;x, y&quot;, xlab = &quot;Time&quot;, pch=15) lines(t, y, type = &quot;b&quot;, col = &quot;darkorange&quot;, pch =19) }) Notice that after 40 days, the values of \\(x\\) and \\(y\\) appear to be approaching some value asymptotically. This is an important feature of these systems, one that we would like to explore a bit more in the following sections. We can translate Ross’s basic description of a process into a model, but first, we need to start using mathematical symbols and notation to represent the process. The model itself is formulated as a set of coupled difference equations, but we will write down the equations last. To get there, we must learn about the parts of a model: variables, initial conditions, and parameters. In the following, we also want to write R code to implement and solve the model. We will be adopting some conventions that end up being very useful. So really, this is a lesson about two things. 2.1.4 Computation If we want to repeat tasks, we can simply write a wrapper around other functions that expedite the work. In this case, we want to write a function that solves the equations (i.e. that iteratively computes and stores the values) over some time interval: solve_ross_dts_1 = function(pars, x0=.01, y0 = 0.001, tmax=100){ xy = c(t=0, x=x0, y=y0) xy_t = xy for(t in 1:tmax){ xy = ross_dts_1(xy, pars) xy_t = rbind(xy_t, xy) } return(list(t=xy_t[,1], x=xy_t[,2], y = xy_t[,3], last = xy)) } We can write another function that plots the equations (i.e. that iteratively computes and stores the values) over some time interval: plot_xy = function(xy_t, add_points = FALSE){with(xy_t,{ llty = &quot;l&quot; if(add_points == TRUE) llty = &quot;b&quot; plot(t, x, type = llty, ylim = c(0,1), col = &quot;darkgreen&quot;, ylab = &quot;x, y&quot;, xlab = &quot;Time&quot;, pch=15) lines(t, y, type = llty, col = &quot;darkorange&quot;, pch =19) })} Now, all the work we did above can be plotted using a single function call: plot_xy(solve_ross_dts_1(ross_dts_par, tmax=40), add_points=TRUE) Now, it is easier to use the models in various ways. 2.1.5 Steady States The fact that our variables asymptotically approach some values over time is an important feature of dynamical systems, so we would like to do some analysis to understand it better. In the following, we compute how much the system is changing over time. We can simply iterate once and compare the differences. After iterating 40 times, the differences are very small: # The last value is still stored as xy; the [-1] omits t xy[-1] - ross_dts_1(xy, ross_dts_par)[-1] ## x y ## -3.545225e-05 -1.355019e-04 If we iterate another hundred days and check again, the differences have gotten even smaller: for(i in 41:140){ xy = ross_dts_1(xy, ross_dts_par) xy_t = rbind(xy_t, xy) } xy[-1] - ross_dts_1(xy, ross_dts_par)[-1] ## x y ## 0 0 After simulating, the variables reach a steady state, where asymptotically \\(x_{t+1} = x_t\\) and \\(y_{t+1} = y_t\\). We can figure out the steady state values are by substituting \\(x_{t+1} = x_t = x\\) and \\(y_{t+1} = y_t = y\\) into the equations above, and then solving for \\(x\\) and \\(y\\). \\[ \\begin{array}{rl} x &amp;= x - s x + m a y (1-x) \\\\ y &amp;= y - u y + a x (1-y) \\\\ \\end{array} \\] or after cancelling and rearranging: \\[\\begin{array}{rl} m a y (1-x) &amp;= s x \\\\ a x (1 - y) &amp;= u y\\\\ \\end{array}\\] The most obvious solution to these equations is \\(x=y=0,\\) which in these models means that there is no malaria. We call it the disease-free steady state. The equilibrium makes some sense: if there are no infected mosquitoes or infected humans in a deterministic model, there can never be any. There is another solution where malaria is present. We solve the second equation first: \\[y = a x / (u + a x).\\] We can substitute this for \\(x\\) into the first equation to get: \\[m a^2 (1-x) = s (u+ax)\\] and now we solve for \\(x\\) \\[x = \\frac{\\textstyle{ma^2 - su}}{\\textstyle{ma^2 + sa}}\\] We can write a function to compute this steady state: # Compute the steady state find_eq_dts_a = function(par){with(par,{ xx = (m*a^2 - s*u)/ (m*a^2 + s*a) yy = a*xx/(u+a*xx) c(x=xx,y=yy) })} 2.1.6 Thresholds All our analysis worked out well for the parameter values that we chose, but what if we had picked different parameters? There must be some very low level of mosquitoes, for example, where malaria can’t reproduce. If we reduce \\(m\\) to \\(0.005\\) and evaluate the expression at the steady state, we get negative values for \\(x\\) and \\(y\\). ross_dts_par1 = ross_dts_par ross_dts_par1$m = 0.005 find_eq_dts_a(ross_dts_par1) ## x y ## -0.06666667 -0.25000000 What happens if we simulate this? (Let’s set the initial conditions to reasonably high values) plot_xy(solve_ross_dts_1(ross_dts_par1, x0 = .5, y0=.3, tmax=1500)) Our function find_eq_dts_a gives us a negative number. find_eq_dts_a(ross_dts_par1) ## x y ## -0.06666667 -0.25000000 If we look at the equations, it’s easy enough to spot the problem. Since \\(x\\) and \\(y\\) must be positive, then it must be true that \\[m a^2 &gt; su.\\] We call this a threshold condition. m_crit = with(ross_dts_par, s*u/a^2) m_crit ## [1] 0.006666667 If we check, we find that this gives us the disease free equilibrium. ross_dts_par2 = ross_dts_par ross_dts_par2$m = m_crit find_eq_dts_a(ross_dts_par2) ## x y ## 0 0 We need a better function: # Compute the steady state find_eq_dts_1 = function(par){with(par,{ xx = ifelse(m*a^2 &gt; s*u, (m*a^2 - s*u)/(m*a^2 + s*a), 0) yy = a*xx/(u+a*xx) c(x=xx,y=yy) })} find_eq_dts_1(ross_dts_par1) ## x y ## 0 0 2.1.7 Verification We want to get used to double checking everything to avoid inserting mistakes. One way to do this is to find two or more ways of computing the same thing, for verification. If we’ve done everything right, we ought to get the same values for the steady states through our analysis and simulation. xy[-1] ## x y ## 0.9867987 0.7475000 find_eq_dts_1(ross_dts_par) ## x y ## 0.9867987 0.7475000 It’s tempting to look at the printout and assume these two numbers are exactly equal. This is the land of computation, so things won’t be exact. We can simply sum up the absolute values of the differences: verify_dts_1 = function(xy, ross_dts_pars){ sum(abs(xy[-1] - find_eq_dts_1(ross_dts_pars))) } verify_dts_1(xy, ross_dts_par) ## [1] 3.330669e-16 If we wanted to reduce this to a simple error check, we should pick a tolerance level – say \\(10^{-9}\\) – and then just ask if we are closer than that: check_it_dts_1 = function(xy, ross_dts_pars, tol=1e-9) { verify_dts_1(xy, ross_dts_pars) &lt; tol } check_it_dts_1(xy, ross_dts_par) ## [1] TRUE 2.1.8 Numerical Instability There is another problem with the equations. If we set \\(m\\) too high, such that at some point \\(m a y_t &gt; 1,\\) then the whole system eventually crashes: ross_dts_par3 = ross_dts_par ross_dts_par3$m = 20 plot_xy(solve_ross_dts_1(ross_dts_par3, x0 = .01, y0=.001, tmax=20)) In discrete time formulations, we must be very careful to ensure that we have formulated a proper model. How can we fix this problem? We have to go back and rethink the way we formulated our model. How does the probability of getting infected scale with the number of infective bites? 2.1.9 ross_dts_2 2.1.9.1 Attack Rates One way to do this is to say that the expected number of bites would follow a Poisson distribution with mean \\(may_t,\\) so that the fraction getting infected is the zero term from a Poisson: \\[1 - e^{-m a y_t}\\] Now, our equations are the following: \\[\\begin{array}{rl} x_{t+1} &amp;= x_t - s x_t + (1-e^{m a y_t}) (1-x_t) \\\\ y_{t+1} &amp;= y_t - u y_t + a x_t (1 - y_t) \\\\ \\end{array}\\] 2.1.9.2 Steady States Now, if we want to compute the steady state, we’re stuck with the problem of solving this: \\[(1-e^{-m a^2 x/(u + a x)}) (1-x) = sx\\] It’s surprisingly easy to write down equations, like this one, that we can’t solve with pencil and paper. We can still find a way of computing the steady state, but we have to write R code that solves for \\(x\\) numerically. find_eq_dts_2 = function(pars){with(pars,{ f_xx = function(x, pp){with(pp,{ xx = (1 - exp(-m*a^2*x/(u+a*x)))*(1-x) - s*x y = a*xx/(u+a*xx) yy = u*y + a*xx*(1-y) return(xx^2 + yy^2) })} xx = optimize(f_xx, c(0,1), pp=pars)$min yy = a*xx/(u+a*xx) c(xx, yy) })} The new equilibrium is at: find_eq_dts_2(ross_dts_par3) ## [1] 0.9949026 0.7490406 2.1.9.3 Workflows We can just as easily write the code to numerically solve the discrete time system: # INPUTS # xy - current variables, as a named vector # p - the parameters, as a list # # OUTPUTS # the updated values of the variables, as a named vector ross_dts_xy_2 = function(xy, p){with(as.list(xy), with(p,{ xn = x - s*x + (1-exp(-m*a*y))*(1-x) yn = y - u*y + a*x*(1-y) t=t+1 return(c(t=t, x=xn, y=yn)) }))} Once again, we can wrap a function around the solver so that it’s easier to use the code: solve_dts_xy_2 = function(pars, x0=.01, y0 = 0.001, tmax=100){ xy = c(t=0, x=x0, y=y0) xy_t = xy for(t in 1:tmax){ xy = ross_dts_xy_2(xy, pars) xy_t = rbind(xy_t, xy) } return(list(t=xy_t[,1], x=xy_t[,2], y = xy_t[,3], last = xy)) } Now, we can visualize the output and see that we have fixed our stability problem. plot_xy(solve_dts_xy_2(ross_dts_par3, x0 = .01, y0=.001, tmax=20)) 2.1.9.4 Verification find_eq_dts_2(ross_dts_par3) ## [1] 0.9949026 0.7490406 solve_dts_xy_2(ross_dts_par3, x0=.1, y0=.05,tmax=300)$last[-1] ## x y ## 0.9949051 0.7490410 Once again, we want to ensure that our code does not have any mistakes, so we write a function to verify our results. verify_dts_2 = function(pars, x0 = .1, y0=.05, tmax=200){ xyt = solve_dts_xy_2(pars, x0=x0, y0=y0, tmax=tmax) sum(abs(xyt$last[-1] - find_eq_dts_2(pars))) } verify_dts_2(ross_dts_par3, tmax=300) ## [1] 2.924525e-06 A function to check that it is accurate to some level of tolerance, but the numerical precision is mismatched, somehow. check_it_dts_2 = function(pars, x0 = .1, y0=.05, tmax=200, tol=1e-5) { verify_dts_2(pars, x0, y0, tmax) &lt; tol } check_it_dts_2(ross_dts_par3, tmax=200) ## [1] TRUE "],["xdeRoss.html", "2.2 Deterministic, Continuous Time", " 2.2 Deterministic, Continuous Time We now want to formulate a new model in continuous time using the same basic assumptions about the life-cycle as before. After seeing the ross_dts models, this model will look and feel familiar. Instead of describing a difference over a fixed time step, we describe a derivative. Instead of describing the fraction of a population that changes, we describe the rates of change over an infinitesimally small interval of time, called a derivative. To understand the mathematics of differential equations, you will need a background in calculus. If you’ve had a semester of calculus, you will have come across derivatives. Depending on how much calculus, you might not have solved differential equations. The point of this book is to introduce malaria analytics, so we will not be delving into mathematical theory or numerical methods very much. In discrete-time, the equations could be written in this form: \\[ \\begin{array}{rl} x_{t+1} - x_t &amp;= F_x (x_t, y_t) \\\\ y_{t+1} - y_t &amp;= F_y (x_t, y_t) \\\\ \\end{array} \\] The left hand side says “the difference in” \\(x\\) or \\(y\\) “over one time step is equal to” \\(F_x\\) or \\(F_y,\\) which are functions of the two variables. We can now ask what would happen if we sub-divided a day into \\(n\\) equal periods. In the limit as \\(n\\) goes to infinity, we replace the differences (terms on the left hand side) with derivatives. The differential equations are now written in this form: \\[ \\begin{array}{rl} \\frac{\\textstyle{dx}}{\\textstyle{dt}} &amp;= F_x (x, y) \\\\ \\frac{\\textstyle{dy}}{\\textstyle{dt}} &amp;= F_y (x, y) \\\\ \\end{array} \\] These differential equation models have the same components as the difference equations: variables, initial conditions, and parameters. To compute anything, we will need to use numerical methods. Fortunately, R has a package to handle numerical methods for differential equations, called deSolve. library(deSolve) Here, we present and solve ross_xdea continuous time, deterministic model that is similar to Ross’s 2nd model [1]. 2.2.1 ross_xde Variables – In ross_xde, the dependent variables have the same meaning as in the ross_dts equations, but the independent variable. We now write an equation describing the fraction of humans and mosquitoes that are infected at each point in time. Let \\(x(t)\\) be the fraction of people who are infected at time \\(t,\\) and \\(0 \\leq x(t) \\leq 1.\\) Let \\(y(t)\\) be the fraction of mosquitoes who are infected at time \\(t,\\) \\(0 \\leq y(t) \\leq 1.\\) Initial Conditions – As before, we will need to define initial conditions. ross_xde_inits = c(x=0.01, y=0.01) Parameters – In this model, the parameters describe rates of change. Let \\(r\\) denote the fraction of people who clear infections after one day; \\(0 &lt; r &lt; 1.\\) Let \\(g\\) denote the fraction of mosquitoes who die in one day; \\(0 &lt; g &lt; 1.\\) Let \\(a\\) denote the fraction of mosquitoes who blood feed on a human in a day; \\(0 &lt; a &lt; 1.\\) Let \\(m\\) denote the number of mosquitoes per human; \\(m \\geq 0.\\) # The parameters, as list ross_xde_par = list( r = 1/200, # The clearance rate for infections g = 1/12, # The mosquito daily death rate a = 1/4, # The mosquito human blood feeding rate m = 0.5 # The number of mosquitoes per human ) Equations – Finally, we put all this together into a mathematical statement that has translated the description of a process. There are four terms: The fraction of humans who are infected is \\(x\\); infections clear at the rate \\(r.\\) The fraction of mosquitoes who are infected is \\(y\\); mosquitoes die at the rate \\(g.\\) The fraction of humans who are infected is \\(1-x\\); infections occur at the rate \\(m a y.\\) The fraction of mosquitoes who are not infected is \\(1-y\\); infections occur at the rate \\(a x.\\) \\[ \\begin{array}{rl} dx/dt &amp;= may(1-z) - r x\\\\ dy/dt &amp;= ax(1-y) - g y \\\\ \\end{array} \\] The form of the function that computes the derivatives in R is defined by deSolve # INPUTS # t - the current time # vars - the variables, as a named vector # pars - the parameters, as a list # OUTPUTS # the derivatives, as a list ross_xde = function(t, vars, pars){ with(pars, with(as.list(vars),{ dxdt = m*a*y*(1-x) - r*x dydt = a*x*(1-y) - g*y return(list(c(dxdt, dydt))) }) ) } Rates vs. Proportions The rates in differential equations can be compared to the proportions in discrete time systems. When the rates describe a change of state, a loss term for one of the variables, there are two easy interpretations. First, we consider the rate of loss of infected humans in a population, \\(-rx.\\) The core underlying process is exponential decay. If we followed a cohort, the waiting time for an individual to change states would follow an exponential distribution with rate \\(1/r\\). Second, after one day, the fraction that remains infected is \\(e^{-r}\\). If we set \\(r=1/200,\\) for example, the expected waiting time to clear an infection is 200 days. The rate of loss after one day is very close to, but slightly less than \\(r\\): c(1/200, 1-exp(-1/200)) ## [1] 0.005000000 0.004987521 Solutions – we now want to solve the initial value problem: given \\(x(0)\\) and \\(y(0),\\) can we find solutions \\(x(t)\\) and \\(y(t)\\)? To do so, we call deSolve::ode, which takes for arguments: the initial values, the points in time to ouput values of \\(x(t)\\) and \\(y(t)\\), a function that computes the derivatives, and the parameters: deSolve::ode(ross_xde_inits, 0:5, ross_xde, ross_xde_par) ## time x y ## 1 0 0.01000000 0.01000000 ## 2 1 0.01128886 0.01172469 ## 3 2 0.01279276 0.01363682 ## 4 3 0.01453497 0.01577333 ## 5 4 0.01654339 0.01817408 ## 6 5 0.01884959 0.02088053 2.2.2 Computation &amp; Visualization For easy in working with these equations, we write a wrapper: # INPUTS: # pars -- the parameter values, as a list # x0 -- the initial value for x(t) # y0 -- the initial value for y(t) # tmax -- the largest value of t # dt -- the interval for t # OUTPUT: # the output of ode as a data.frame solve_ross_xde = function(pars, x0=.01, y0=0.001, tmax=100, dt=1){ tms = seq(0, tmax, by = dt) xy0 = c(x=x0, y=y0) data.frame(ode(xy0, tms, ross_xde, pars)) } deout &lt;- solve_ross_xde(ross_xde_par) Because we have returned it as a data frame, the column names are time and x and y. We can plot the values using with(). with(deout, { plot(time, x, type = &quot;l&quot;, col = &quot;darkgreen&quot;, ylim = c(0,1), ylab = c(&quot;x, y&quot;)) lines(time, y, col = &quot;darkorange&quot;) }) These differential equations require 2.2.3 Steady States We can learn a bit more about how these equations behave by changing the initial values: deout1 &lt;- solve_ross_xde(ross_xde_par, x0=0.2, y0=0.02) deout2 &lt;- solve_ross_xde(ross_xde_par, x0=.99, y0=0.99) with(deout, { plot(time, x, type = &quot;l&quot;, col = &quot;darkgreen&quot;, ylim = c(0,1), ylab = c(&quot;x, y&quot;)) lines(time, y, col = &quot;darkorange&quot;) }) with(deout1, { lines(time, x, type = &quot;l&quot;, col = &quot;darkgreen&quot;, lty=2) lines(time, y, col = &quot;darkorange&quot;, lty=2) }) with(deout2, { lines(time, x, type = &quot;l&quot;, col = &quot;darkgreen&quot;, lty=3) lines(time, y, col = &quot;darkorange&quot;, lty=3) }) We notice that the orbits all asymptotically approach the same value, regardless of where they started. Once there, they stay there. 2.2.4 Verification We ought to be able to compute the value of these steady states: it is a value of \\(x(t)\\) and \\(y(t)\\) such that \\(dx/dt=dy/dt=0.\\) To find it, we set \\(dx/dt=dy/dt=0\\) and solve for \\(x\\) and \\(y.\\) One obvious value, once again, is \\(x=y=0.\\) \\[ \\begin{array}{rl} 0 &amp;= may(1-x) - r x\\\\ 0 &amp;= ax(1-y) - g y \\\\ \\end{array} \\] Solve the second equation for \\(y\\) \\[y = ax/(g+ax)\\] Substitute back into the first equation: \\[ma^2 (1-x) = r(g+ax)\\] and solve. \\[x = \\frac{\\textstyle{m a^2 - rg}}{\\textstyle{m a^2 + ra}}\\] Noting that \\(m a^2 &gt; rg\\) must be a threshold condition, we write a function to compute the steady state using the formula we just derived: find_eq_xde_1 = function(pars){with(pars,{ xx = ifelse(m*a^2 &gt; r*g, (m*a^2 - r*g)/(m*a^2 + r*a), 0) yy = a*xx/(g+a*xx) c(x=xx, y=yy) })} find_eq_xde_1(ross_xde_par) ## x y ## 0.9487179 0.7400000 We check it against the other way, which involves running the system for a very long time. de_eq &lt;- solve_ross_xde(ross_xde_par, tmax=500, dt=5) with(de_eq, c(x=tail(x,1), y=tail(y,1))) ## x y ## 0.9487179 0.7400000 2.2.5 Thresholds References "],["sdtsRoss.html", "2.3 Stochastic, Discrete Time", " 2.3 Stochastic, Discrete Time Parameters – We can use the same parameters as before, but there are two new parameters: \\(M\\) is the number of mosquitoes: \\(M\\) is a counting number \\(H\\) is the number of humans; \\(H\\) is a counting number # The parameters, as a list ross_sdts_par = list( M = 150, # The number of mosquitoes H = 100, # The number of humans s = 1/200, # The fraction of infections that clear each day u = 1/12, # The fraction of mosquitoes that die each day a = 1/4 # The fraction of mosquitoes that blood feed on a human each day ) Variables \\(Y \\leq M\\) is the number of infected mosquitoes: \\(Y\\) is a counting \\(X \\leq H\\) is the number of infected humans ross_sdts = function(XY, p){ with(as.list(XY), with(p,{ ar = 1 - exp(-a*Y/H) Xn = rbinom(1, X, 1-s) + rbinom(1, H-X, ar) Yn = rbinom(1, Y, 1-u) + rbinom(1, M-Y, a*X/H) t=t+1 return(c(t=t, X=Xn, Y=Yn)) }))} sim_ross_sdts = function(pars, X0=2, Y0 = 1, tmaX=100){ XY = c(t=0, X=X0, Y=Y0) XY_t = XY for(t in 1:tmaX){ XY = ross_sdts(XY, pars) XY_t = rbind(XY_t, XY) } X=XY_t[,2] Y=XY_t[,3] x=X/pars$H y=Y/pars$M return(list(t=XY_t[,1], x=x, y=y, X=X, Y=Y, last = XY)) } We can write another function that plots the equations (i.e. that iteratively computes and stores the values) over some time interval: plot_XY = function(xy_t, add_points = FALSE){with(xy_t,{ llty = &quot;l&quot; if(add_points == TRUE) llty = &quot;b&quot; plot(t, X, type = llty, ylim = range(0, X, Y), col = &quot;darkgreen&quot;, ylab = &quot;X, Y&quot;, xlab = &quot;Time&quot;, pch=15) lines(t, Y, type = llty, col = &quot;darkorange&quot;, pch =19) })} XYt &lt;- sim_ross_sdts(ross_sdts_par) par(mfrow = c(2,1)) plot_XY(XYt) plot_xy(XYt) 2.3.1 Stochastic Fadeout 2.3.2 Steady States "],["sxdeRoss.html", "2.4 Stochastic, Continuous Time", " 2.4 Stochastic, Continuous Time In continuous time, the state of the system is updated one event at a time. The total rate of change of the system is \\(T = may(H-X) + rX + aX(M-Y) + gY\\) \\(Y \\rightarrow Y+1\\) \\(Y \\rightarrow Y-1\\) \\(X \\rightarrow X+1\\) \\(X \\rightarrow X-1\\) # The parameters, as list ross_sxde_par = list( r = 1/200, # The clearance rate for infections g = 1/12, # The mosquito daily death rate a = 1/4, # The mosquito human blood feeding rate M = 150, # The number of mosquitoes H = 100 # The number of humans ) ross_sxde = function(XY, pars){ with(as.list(XY), with(pars,{ p1 = a*Y*(H-X)/H p2 = r*X p3 = a*X*(M-Y)/H p4 = g*Y t = t + rexp(1, p1+p2+p3+p4) event = sample(1:4, 1, prob=c(p1, p2, p3, p4)) if (event==1) X &lt;- X+1 if (event==2) X &lt;- X-1 if (event==3) Y &lt;- Y+1 if (event==4) Y &lt;- Y-1 return(c(t=t, X=X, Y=Y, x=X/H, y=Y/M)) }))} xy = c(t=0, X=3, Y=1) for (i in 1:10){ xy &lt;- ross_sxde(xy, ross_sxde_par) print(xy) } ## t X Y x y ## 1.757895877 4.000000000 1.000000000 0.040000000 0.006666667 ## t X Y x y ## 2.01357831 4.00000000 2.00000000 0.04000000 0.01333333 ## t X Y x y ## 2.427999 4.000000 3.000000 0.040000 0.020000 ## t X Y x y ## 2.46902034 4.00000000 4.00000000 0.04000000 0.02666667 ## t X Y x y ## 2.72894367 5.00000000 4.00000000 0.05000000 0.02666667 ## t X Y x y ## 2.96285360 4.00000000 4.00000000 0.04000000 0.02666667 ## t X Y x y ## 3.04429497 5.00000000 4.00000000 0.05000000 0.02666667 ## t X Y x y ## 4.09664257 6.00000000 4.00000000 0.06000000 0.02666667 ## t X Y x y ## 4.48053823 6.00000000 5.00000000 0.06000000 0.03333333 ## t X Y x y ## 4.716033 6.000000 6.000000 0.060000 0.040000 sim_ross_sxde = function(pars, X0=2, Y0=1, tmax=100){ XY = c(t=0, X=X0, Y=Y0) tm = XY[1] XY_t = c() while(tm &lt; tmax){ XY = ross_sxde(XY, pars) tm = XY[1] XY_t = rbind(XY_t, XY) } return(list(t=XY_t[,1], X=XY_t[,2], Y=XY_t[,3], x = XY_t[,4], y = XY_t[,5])) } out &lt;- sim_ross_sxde(ross_sxde_par) par(mfrow = c(2,1)) plot_XY(out) plot_xy(out) "],["comparing-models.html", "2.5 Comparing Models", " 2.5 Comparing Models "],["notes.html", "2.6 Notes", " 2.6 Notes 2.6.1 Why use densities? To show why we use densities, we present a simple example. If we write down an equation describing changes in the density of infected humans, \\(X\\), in a population with total human population density \\(H\\). We let \\(V\\) denote vectorial capacity, and \\(b\\) the fraction of infective bites that cause an infection, and we assume the force of infection is \\(bVX/H\\). The dynamics of infection are described by this simple equation: \\[\\frac{dX}{dt} = bV\\frac{X}{H}(H-X)-rX\\] In this equation, prevalence is \\(x = X/H.\\) Following through with the change in variables, we can write down the equation for the change in prevalence: \\[\\frac{dx}{dt} = \\frac{1}{H^2} \\left(H \\frac{dX}{dt} - X \\frac{dH}{dt} \\right)\\] and with some rearranging, we get: \\[\\frac{dx}{dt} = bVx(1-x)-rx -x \\frac{dH}{dt}\\] The second equation is as simple as the first only if \\(dH/dt=0\\). Since we will want to deal with dynamical changes in host populations, we will avoid formulating base models that have proportions. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
