[["2-basic-malaria-models.html", "2 Basic Malaria Models", " 2 Basic Malaria Models Basic malaria models as deterministic or stochastic systems of difference or differential equations As Ross was planning malaria control activities, he sought to develop mathematics for support to help him set rational expectations about the likely outcomes of control. Given his interests in malaria metrics, he sought to understand why malaria prevalence differed from place to place. To explain these differences, so he developed mathematical models that described infection and the loss of infection, the processes affecting how malaria prevalence would change over time. Malaria infections in two host populations – humans and mosquitoes – are connected through mosquito blood feeding, so malaria transmission works as an integrated system. The process looks something like the following diagram. Infection Dynamics – The parasite life-cycle involves a dynamic process in two host populations, and it requires blood meals. Uninfected mosquitoes get infected when they take up parasites after blood feeding on an infected human. Uninfected humans become infected by the mosquitoes transmitted in saliva when a mosquito bites, prior to blood feeding. This graph is the basis for causal theory for malaria parasite propagation in populations, but students of causation might object that the graph describes a cycle and thus it can not be causal. If we applied the logic more generally, no graph describing any organisms life cycle would be causal, and yet life is undoubtedly the cause of life. The missing element is time: a life-cycle graph would be directed and acyclic if it had an arrow that traced life in one generation giving rise to life in the next. To understand this as a causal diagram, we must thus imagine that it describes a dynamical process in populations: infected mosquitoes today are biting and infecting humans tomorrow; and infectious humans today are causing infections in mosquitoes tomorrow when they take a blood meal. Seen in this way, we can begin to develop a quantitative theory that describes all the factors that determines malaria prevalence in populations. How does malaria persist in a population? It persists through the transmission of parasites among hosts during blood feeding. What factors determine prevalence? It is a balance between the gain and loss of infection. To develop a mathematical model, Ross believed that it was possible to write down a priori – or in other words, to formulate mathematical models using quantitative logic – a description of the process. To write down the model, we must make some assumptions about the process. We begin with an abstract concept of place – here. We imagine that populations here are comprised of individual mosquitoes and individual humans, and we are interested in computing the fractions of humans and mosquitoes that are infected. Since infections don’t last forever, the prevalence of infection in mosquitoes and humans reflects a balance between infections acquired through parasite transmission and the natural loss of infection through parasite clearance or host mortality. In many places, forces affecting the the balance can be changing; mosquito population density fluctuates over time, for example. Ross’s equations assumed that transmission by mosquitoes was constant over time, and they focused on local transmission, ignoring exposure elsewhere (e.g. through travel). This model thus ignores many factors that would be important for planning for control. Ross discussed all these factors, but since he was pioneering a new approach, the models were very simple. Mosquitoes lived short lives, so the loss of parasites in mosquitoes would mainly occur through mosquito mortality: \\[\\begin{equation} \\mbox{MOSQUITOES} \\\\ \\; \\\\ \\left[ \\begin{array}{rcl} \\mbox{Infected Tomorrow} &amp;=&amp; \\mbox{Infected Today} \\\\ &amp;-&amp;\\mbox{Infected: Died}\\\\ &amp;+&amp;\\mbox{Uninfected: Got Infected}\\\\ \\end{array} \\right] \\tag{2.1} \\end{equation}\\] This description of a process ignores the loss of infection in mosquitoes, and changing mosquito population density. It ignores the extrinsic incubation period (EIP), the lag between the point in time when a mosquito gets infected and when it becomes infectious. This basic description of the process does not explicitly address the process that gives rise to uninfected mosquitoes. The mathematical formulation implies, without stating it explicitly, that each dying infected mosquito gets replaced by an uninfected mosquito emerging from an aquatic habitat. Otherwise, the mosquito population would declining over time. Ross was interested in malaria transmission dynamics, so the mosquito ecology was almost invisible. Humans live long lives, so parasite loss would mainly occur through natural clearance. \\[\\begin{equation} \\mbox{HUMANS} \\\\ \\; \\\\ \\left[ \\begin{array}{rcl} \\mbox{Infected Tomorrow} &amp;=&amp; \\mbox{Infected Today} \\;\\; \\\\ &amp;-&amp; \\mbox{Infected: Cleared Infection}\\\\ &amp;+&amp; \\mbox{Uninfected: Got Infected}\\\\ \\end{array} \\right] \\tag{2.2} \\end{equation}\\] This description of the process thus ignores human demography, including births, deaths, and migration. The model also ignores a large number of other factors, including superinfection, the complex time course of an infection, immunity, and treatment with anti-malarial drugs. (In Ross’s day, quinine was expensive and difficult to obtain, but it was sometimes used.) To describe malaria transmission and factors that determine the prevalence of malaria in human populations over time, we formulate mathematical models as dynamical systems. In the sections that follow, we will formulate dynamical systems in discrete and continuous time, and as a deterministic or stochastic processes. In the following, we will write down several distinct sets of mathematical equations that follow the basic rules described above: In Section 2.1, we present two basic deterministic discrete-time systems. In Section 2.2, we present a stochastic discrete-time system; In Section 2.3, we present a deterministic continuous-time system; In Section 2.4, we present a stochastic process in continuous-time; In Section 2.5, we compare and contrast these four mathematical species. As a reminder, we’re not trying to delve too deeply into malaria epidemiology with the models in this chapter. Instead, this chapter is about trying to develop a toolbox that we can use to investigate malaria transmission dynamics and control. Our goals are thus to learn the basic elements of different kinds of models, and to develop some basic intuition about the different kinds of models that exist, and how we can think about models as approximations. Each model is implemented as R code1 Later, we will start using some R packages that were developed to support robust analytics for malaria policy. Later, we’ll worry about modifying the assumptions to ensure that we are dealing with the issues that matter for in malaria policy. In developing this book, we assumed the reader would be familiar with R and RStudio.↩︎ "],["2.1-dtsRoss.html", "2.1 Deterministic, Discrete Time", " 2.1 Deterministic, Discrete Time The parts of a model: variables, parameters, initial conditions. In this section, we present the basic, deterministic, discrete-time model for a mosquito-transmitted pathogen. Because it is the first model in the book, we’ll take the time to explain some background material in detail. We’ll discuss the parts of a model, and we walk through sections about solving, computation, analysis, and model verification. The first model we present, called ross_dts_1, we is numerically unstable in some cases. At the end we present another model, called ross_dts_2 that is numerically stable. 2.1.1 ross_dts_1 We will present the parts of the model first, and write down the equations last. The parts of a model are called parameters and variables. To solve the model, we will need initial conditions for the variables. As we go, we will also write R code that implements the model and that solves it. In writing the code, we will adopt some conventions that we can use to help us write good code. Variables are quantities that describe the state of a system. One variable in this model is time, denoted \\(t.\\) The dependent variables are the quantities that we want to compute, and they are computed at various time points. Time is marching forward, unaffected by the dependent variables, so we call it the independent variable. In this model, there are two dependent variables: the proportion of humans and mosquitoes that are infected at each point in time. Since it is a discrete time system, the values of the variables are defined only at integer values of \\(t.\\) We define the variables as follows: let \\(t\\) represent time, in days; let \\(x_t\\) be the fraction of people who are infected at time \\(t,\\) and \\(0 \\leq x_t \\leq 1;\\) let \\(y_t\\) be the fraction of mosquitoes who are infected at time \\(t,\\) \\(0 \\leq y_t \\leq 1.\\) Another term for the fraction of a population that infected with parasites is prevalence. Initial Conditions are the values of the variables at one point in time. Since the values of our variables in the next time step (at time \\(t+1\\)) depend on their values now (at time \\(t\\)), we can’t really compute anything specific unless we specify the values of the variables at one point in time. Having set one set of values, we can use the equations to compute the rest. The initial conditions specify the values of all our variables at the beginning of the simulation. By convention, this is usually at time \\(t=0,\\) but we could also specify their values at any other point in time. We can now begin to write R code to set up the objects so we can compute them. We set these initial values to be small: # Initial Conditions at a point in time, as a Named Vector xy = c(t=0, x=0.01, y=0.001) In R, this object xy is called a named vector. The names are carried along but they don’t affect any computation done with xy. It is also useful that the names often get inherited (but not always). The names can be used with as.list() or data.frame(). When combined with the with() function, we can create a context where we can call them by name: with(as.list(xy), x) ## [1] 0.01 This code has adopted the convention of using named vectors so that we can write functions in a way that is easy to read. It also makes it easier to deal with the model outputs. Parameters are quantities – rates, numbers, or probabilities – that describe some part of the process. Unlike variables, parameter values are chosen outside of a model and passed to it. In ross_dts_1, these parameters are constant. Since they are constant, we call this an autonomous system of equations. In other models, we could have parameter values that changes over time, so the system would be called non-autonomous. The parameters in this model define changes in prevalence: the fraction of humans that clear an infection each day; the fraction of infected mosquitoes that die; and blood feeding and infection. Let \\(s\\) denote the fraction of people who clear infections after one day; \\(0 &lt; s &lt; 1.\\) Let \\(u\\) denote the fraction of mosquitoes who die in one day; \\(0 &lt; u &lt; 1.\\) Let \\(a\\) denote the fraction of mosquitoes who blood feed on a human in a day; \\(0 &lt; a &lt; 1.\\) Let \\(m\\) denote the number of mosquitoes per human; \\(m \\geq 0.\\) # The parameters, as a list ross_dts_par = list( s = 1/200, # The fraction of infections that clear each day u = 1/12, # The fraction of mosquitoes that die each day a = 1/4, # The fraction of mosquitoes that blood feed on a human each day m = 2 # The number of mosquitoes per human ) Equations describe dynamic changes in the variables over time. In this case, the process is described by a system of coupled difference equations. Finally, we put all this together into a mathematical statement that has translated the description of a process, that are describe the process. \\[\\begin{equation} \\begin{array}{rl} x_{t+1} &amp;= x_t - s x_t + m a y_t (1-x_t) \\\\ y_{t+1} &amp;= y_t - u y_t + a x_t (1 - y_t) \\\\ \\end{array} \\tag{2.3} \\end{equation}\\] We could rewrite the equations to make it easier to interpret them. \\[\\begin{equation} \\begin{array}{rl} x_{t+1} - x_t &amp;= - s x_t + m a y_t (1-x_t) \\\\ y_{t+1} - y_t &amp;= - u y_t + a x_t (1 - y_t) \\\\ \\end{array} \\tag{2.4} \\end{equation}\\] In this alternative way of writing down the equations, the left hand side is interpreted as the daily change, and the terms on the right hand side describes those changes. The RHS has four terms: \\(- s x_t\\) – is a decrease in the prevalence of human malaria infections caused by clearance of human infections: the fraction of humans who are infected is \\(x_t\\); a fraction \\(s\\) clears infections each day. \\(+ may_t (1-x_t)\\) – is an increase in the prevalence of human malaria infections caused by the bites of infectious mosquitoes: the fraction of humans who are not infected is \\(1-x_t\\); a fraction \\(m a y_t\\) gets infected. \\(-u y_t\\) – is a decrease in the prevalence of mosquito malaria infections caused by mosquito mortality: the fraction of mosquitoes who are infected is \\(y_t\\); a fraction \\(u\\) die. \\(+ a x_t (1-y_t)\\) – is an increase in the prevalence of mosquito malaria infections caused blood feeding on an infected human: the fraction of mosquitoes who are not infected is \\(1-y_t\\); a fraction \\(a x_t\\) blood feeds on an infected human and gets infected. To foreshadow something we will address in sub-section 2.1.9, if \\(may_t &gt;1,\\) then it is not a proportion, and the equations don’t make sense. To update the variables, we write a function in R. Since we will be developing a lot of functions and models, we adopt a simple naming convention: since it was developed by Ross, we attach the stem ross; since this is a discrete time system, we attach the suffix dts; we might want to generate other variants, so we append a number. The function is thus called ross_dts_1. # INPUTS # xy - current variables, as a named vector # p - the parameters, as a list # # OUTPUTS # the updated values of the variables, as a named vector ross_dts_1 = function(xy, p){ with(as.list(xy), with(p,{ xn = x - s*x + m*a*y*(1-x) yn = y - u*y + a*x*(1-y) return(c(t=t+1, x=xn, y=yn)) }) ) } 2.1.2 Solving With the R code we developed, we can solve the equations, which involves computing the values of the variables iteratively. Since the values of the variables change, we create another object xy_t that we can use to store the values of computed variables over time. # xy_t stores the values of the variables xy_t = xy We iterate in two steps. First, we compute the values. # Compute xy = ross_dts_1(xy, ross_dts_par) Since we initialized the system at time \\(t=0,\\) the following computes the values of the parameters at time \\(t=1.\\) We can take a peak at the values we computed: # Print to screen print(xy) ## t x y ## 1.000000000 0.010445000 0.003414167 Next, we store the values using rbind # Store xy_t = rbind(xy_t, xy) We can take a peak: # Print to screen print(xy_t) ## t x y ## xy_t 0 0.010000 0.001000000 ## xy 1 0.010445 0.003414167 We can iterate over many time steps, each time storing the values: # Iterate to compute the values as they change over time for(t in 2:40){ xy = ross_dts_1(xy, ross_dts_par) xy_t = rbind(xy_t, xy) } We can look at the last few values, the values of \\(t,\\) \\(x\\) and \\(y\\) are stored in columns: print(tail(xy_t, 3)) ## t x y ## xy 38 0.9865573 0.7465869 ## xy 39 0.9866426 0.7468730 ## xy 40 0.9866975 0.7470700 As we can see, the values are changing a little at the end. 2.1.3 Visualizing We can now plot out the values over the first 40 days. Since xy_t is a named list, we transform it and plot: with(data.frame(xy_t),{ plot(t, x, type = &quot;b&quot;, ylim = c(0,1), ylab = &quot;prevalence&quot;, xlab = &quot;time&quot;, col = &quot;darkgreen&quot;, pch=15) lines(t, y, type = &quot;b&quot;, col = &quot;darkorange&quot;, pch =19) }) Notice that after 40 days, the values of \\(x\\) and \\(y\\) appear to be approaching some value asymptotically. This is an important feature of these systems, one that we would like to understand and explore a bit more in the following sections. 2.1.4 Computation Computers are very good at repeating tasks, but if we want to get the computers to repeat tasks efficiently, we must write code that does it. One useful trick is to write functions that call other functions to expedite workflows. In this case, we want to write a function that solves the equations (i.e. that iteratively computes and stores the values) over some time interval: # INPUTS # pars - the parameters, as a list # x0 - the initial value of x # y0 - the initial value of y # t0 - the initial value of t # tmax - the last value of t # # OUTPUTS # the values of the variables over time, as a list ross_dts_solve_1 = function(pars, x0=.01, y0 = 0.001, t0=0, tmax=100){ xy = c(t=t0, x=x0, y=y0) xy_t = xy for(t in (t0+1):tmax){ xy = ross_dts_1(xy, pars) xy_t = rbind(xy_t, xy) } return(list(time=xy_t[,1], x=xy_t[,2], y = xy_t[,3], last = xy)) } We can write another function that plots the equations (i.e. that iteratively computes and stores the values) over some time interval: # INPUTS # xy_t - a list with elements named x, y, and time # type - plot type: &quot;l&quot; or &quot;p&quot; or &quot;b&quot; # lty - lty # add - if TRUE, add to existing plot # # OUTPUTS # the values of the variables over time, as a list plot_xy = function(xy_t, type = &quot;l&quot;, lty=1, add=FALSE){with(xy_t,{ if(add == FALSE) plot(time, x, &quot;n&quot;, ylim = c(0,1), ylab = &quot;Prevalence&quot;, xlab = &quot;Time&quot;) lines(time, x, type = type, lty=lty, col = &quot;darkgreen&quot;, pch =15) lines(time, y, type = type, lty=lty, col = &quot;darkorange&quot;, pch =19) text(0, 0.9, &quot;x&quot;, col = &quot;darkgreen&quot;, pos=4) text(0, 0.8, &quot;y&quot;, col = &quot;darkorange&quot;, pos=4) })} Now, all the work we did above can be plotted using a single function call: plot_xy(ross_dts_solve_1(ross_dts_par, tmax=40), type=&quot;p&quot;) Now, it is easier to repeat all our analysis with a simple function call. 2.1.5 Steady States The fact that our variables asymptotically approach some values over time is an important feature of dynamical systems, so we would like to do some analysis to understand it better. If we look at Eq. (2.4), we can understand why. In this model, there is no change when the proportion of humans becoming infected is equal to the proportion clearing infections; and the proportion of mosquitoes becoming infected is equal to the proportion dying. In the following, we compute how much the system is changing over time. We can simply iterate once and compare the differences. After iterating 40 times, the differences are very small: # The last value is still stored as xy; the [-1] omits t xy[-1] - ross_dts_1(xy, ross_dts_par)[-1] ## x y ## -3.545225e-05 -1.355019e-04 If we iterate another hundred days and check again, the differences have gotten even smaller: for(i in 41:140){ xy = ross_dts_1(xy, ross_dts_par) xy_t = rbind(xy_t, xy) } xy[-1] - ross_dts_1(xy, ross_dts_par)[-1] ## x y ## 0 0 After simulating, the variables reach a steady state, where asymptotically \\(x_{t+1} = x_t\\) and \\(y_{t+1} = y_t\\). A steady state occurs when there is no daily change, so \\(x_{t+1} - x_t = 0\\) and \\(y_{t+1} - y_t = 0.\\) We can figure out the steady state values are by substituting \\(x_{t+1} = x_t = x\\) and \\(y_{t+1} = y_t = y\\) into Eq.(2.4) and then solving for \\(x\\) and \\(y\\). After cancelling and rearranging, we get: \\[\\begin{equation} \\begin{array}{rl} m a y (1-x) &amp;= s x \\\\ a x (1 - y) &amp;= u y\\\\ \\end{array} \\tag{2.5} \\end{equation}\\] Equations (2.5) say: the proportion of humans becoming infected is equal to the proportion clearing infections; and the proportion of mosquitoes becoming infected is equal to the proportion dying. The most obvious solution to these equations is \\(x=y=0,\\) when there is no malaria. We call it the disease-free steady state. A disease-free equilibrium makes sense, since if we start with no infected mosquitoes or infected humans in this deterministic model, there can never be any. There is another solution where malaria is present. We solve the second equation first: \\[y = a x / (u + a x).\\] Next, we substitute this for the \\(y\\) term that is in the first equation, and we get: \\[m a^2 (1-x) = s (u+ax)\\] and now we solve for \\(x\\) \\[x = \\frac{\\textstyle{ma^2 - su}}{\\textstyle{ma^2 + sa}}\\] We can write a function to compute this steady state: # INPUTS # params - the parameters, as a list # # OUTPUTS # the steady state values of x and y ross_dts_steady_0 = function(params){with(params,{ xx = (m*a^2 - s*u)/ (m*a^2 + s*a) yy = a*xx/(u+a*xx) c(x=xx,y=yy) })} ross_dts_steady_0(ross_dts_par) ## x y ## 0.9867987 0.7475000 2.1.6 Thresholds All our analysis worked out well for the parameter values that we chose, but what if we had picked different parameters? There must be some very low level of mosquitoes, for example, where malaria parasites can’t be sustained in a population. If we reduce \\(m\\) to \\(0.005\\) and evaluate the expression at the steady state, we get negative values for \\(x\\) and \\(y\\). ross_dts_par1 = ross_dts_par ross_dts_par1$m = 0.005 ross_dts_steady_0(ross_dts_par1) ## x y ## -0.06666667 -0.25000000 What happens if we simulate this? (Let’s set the initial conditions to reasonably high values) plot_xy(ross_dts_solve_1(ross_dts_par1, x0 = .5, y0=.3, tmax=1500)) Our function ross_dts_steady_0 gives us a negative number. ross_dts_steady_0(ross_dts_par1) ## x y ## -0.06666667 -0.25000000 If we look at the equations, it’s easy enough to spot the problem. Since \\(x\\) and \\(y\\) must be positive, then it must be true that \\[m a^2 &gt; su.\\] We call this a threshold condition. m_crit = with(ross_dts_par, s*u/a^2) m_crit ## [1] 0.006666667 If we check, we find that this gives us the disease free equilibrium. ross_dts_par2 = ross_dts_par ross_dts_par2$m = m_crit ross_dts_steady_0(ross_dts_par2) ## x y ## 0 0 It doesn’t make sense to have a negative amount of malaria. Since ross_dts_steady_0gives us negative numbers, we can use this little bit of information to write a better function, one that returns \\(0\\) instead of a negative number: # INPUTS # params - the parameters, as a list # # OUTPUTS # the steady state values of x and y ross_dts_steady_1 = function(params){with(params,{ xx = ifelse(m*a^2 &gt; s*u, (m*a^2 - s*u)/(m*a^2 + s*a), 0) yy = a*xx/(u+a*xx) c(x=xx,y=yy) })} ross_dts_steady_1(ross_dts_par1) ## x y ## 0 0 2.1.7 Verification If we’re going to take ourselves seriously, we want to get used to double checking everything to avoid inserting mistakes. One way to do this is to find two or more ways of computing the same thing, for verification. If we’ve done everything right, we ought to get the same values for the steady states through our analysis and simulation. The last values of \\(x\\) and \\(y\\) from the simulation are: xy[-1] ## x y ## 0.9867987 0.7475000 The last values of \\(x\\) and \\(y\\) from evaluating ross_dts_steady_1() are: ross_dts_steady_1(ross_dts_par) ## x y ## 0.9867987 0.7475000 It’s tempting to look at the printout and assume these two numbers are exactly equal, but when we deal with computers, everything gets computed and stored in some way. We can never be sure that a match will be be exact. We can simply sum up the absolute values of the differences: sum(abs(xy[-1] - ross_dts_steady_1(ross_dts_par))) ## [1] 3.330669e-16 If we wanted to reduce this to a simple error check, we should pick a tolerance level – say \\(10^{-9}\\) – and then just ask if we are closer than that: # INPUTS # xy - xy # par - a set of parameters for a ross_dts model # tol - a tolerance level # # OUTPUTS # boolean - ross_dts_checkit_1 = function(xy, ross_dts_pars, tol=1e-9){ sum(abs(xy[-1] - ross_dts_steady_1(ross_dts_pars))) &lt; tol } ross_dts_checkit_1(xy, ross_dts_par) ## [1] TRUE 2.1.8 Numerical Instability There is another problem with the equations. If we set \\(m\\) too high, such that at some point \\(m a y_t &gt; 1,\\) then the whole system eventually crashes: ross_dts_par3 = ross_dts_par ross_dts_par3$m = 20 plot_xy(ross_dts_solve_1(ross_dts_par3, x0 = .01, y0=.001, tmax=20), &quot;b&quot;) In discrete time formulations, we must be very careful to ensure that we have formulated a proper model. How can we fix this problem? We have to go back and rethink the way we formulated our model. How does the probability of getting infected scale with the number of infective bites? 2.1.9 ross_dts_2 There is a good solution to the problem that gave rise to this numerical instability. The question at hand is what fraction of people would become infected, on average, if the expected number of bites was \\(may_t?\\) Ideally, we want to return a proportion, even when \\(may_t&gt;1.\\) We call this quantity – the fraction that gets infected in a day – the daily attack rate. If we knew that there were exactly an integer number of bites, \\(ma,\\) then the proportion of people not getting infected would be those that didn’t get infected from any one of the bites, or \\((1-y_t)^{ma}.\\) There is, however, an even better way to think about this. In a lot of cases like this, without any other information, we would assume that the number of bites, per person, would follow a Poisson distribution. It’s actually easier to say who doesn’t get infected, and that’s the zero term of a Poisson, \\(e^{-may_t}.\\) The probability of getting infected is the complement of the probability of getting at least one bite, or \\[1 - e^{-m a y_t}\\] Equations Our variables, initial conditions, and parameters are all defined in the same way as ross_dts_1, but now our equations have changed: \\[\\begin{equation} \\begin{array}{rl} x_{t+1} &amp;= x_t - s x_t + (1-e^{-m a y_t}) (1-x_t) \\\\ y_{t+1} &amp;= y_t - u y_t + a x_t (1 - y_t) \\\\ \\end{array} \\tag{2.6} \\end{equation}\\] As before, we write a function to numerically solve the discrete time system: # INPUTS # xy - current variables, as a named vector # params - the parameters, as a list # # OUTPUTS # the updated values of the variables, as a named vector ross_dts_2 = function(xy, params){with(as.list(xy), with(params,{ xn = x - s*x + (1-exp(-m*a*y))*(1-x) yn = y - u*y + a*x*(1-y) t=t+1 return(c(t=t, x=xn, y=yn)) }))} Once again, we can wrap a function around the solver so that it’s easier to use the code: # INPUTS # pars - the parameters, as a list # x0 - the initial value of x # y0 - the initial value of y # t0 - the initial value of t # tmax - the last value of t # # OUTPUTS # the values of the variables over time, as a list ross_dts_solve_2 = function(pars, x0=.01, y0 = 0.001, t0=0, tmax=100){ xy = c(t=t0, x=x0, y=y0) xy = c(t=0, x=x0, y=y0) xy_t = xy for(t in (t0+1):tmax){ xy = ross_dts_2(xy, pars) xy_t = rbind(xy_t, xy) } return(list(time=xy_t[,1], x=xy_t[,2], y = xy_t[,3], last = xy)) } Now, we can visualize the output using code we’ve already written, and can see that we have fixed our stability problem. plot_xy(ross_dts_solve_2(ross_dts_par3, x0 = .01, y0=.001, tmax=20), &quot;b&quot;) Verification For verification, we want a method to solve things two different ways. If we want to compute the steady state, we’re stuck with the problem of solving this equation: \\[(1-e^{-m a^2 x/(u + a x)}) (1-x) = sx\\] It’s surprisingly easy to write down equations, like this one, that we can’t solve with pencil and paper. We can still find a way of computing the steady state, but we have to write R code that solves for \\(x\\) numerically. # INPUTS # par - the model parameters, as a list # # OUTPUTS # the steady state values of x and y ross_dts_steady_2 = function(pars){with(pars,{ f_xx = function(x, pp){with(pp,{ xx = (1 - exp(-m*a^2*x/(u+a*x)))*(1-x) - s*x y = a*xx/(u+a*xx) yy = u*y + a*xx*(1-y) return(xx^2 + yy^2) })} xx = optimize(f_xx, c(0,1), pp=pars, tol = 1e-10)$min yy = a*xx/(u+a*xx) c(xx, yy) })} Finding the equilibrium this way, we get: ross_dts_steady_2(ross_dts_par3) ## [1] 0.9949051 0.7490410 Second, by getting the solution after many iterations. ross_dts_solve_2(ross_dts_par3, x0=.1, y0=.05,tmax=300)$last[-1] ## x y ## 0.9949051 0.7490410 By inspection, these two numbers are very close, but not exactly matching. Once again, we want to ensure that our code does not have any mistakes, so we write a function to verify our results. We set a term that describes an acceptable tolerance for computational errors, and ask if we’re at least that close. ross_dts_checkit_2 = function(pars, x0 = .1, y0=.05, tmax=500, tol=1e-7){ xyt = ross_dts_solve_2(pars, x0=x0, y0=y0, tmax=tmax) sum(abs(xyt$last[-1] - ross_dts_steady_2(pars))) &lt; tol } Do the two answers differ by less than \\(10^{-7}\\)? ross_dts_checkit_2(ross_dts_par3) ## [1] TRUE It’s a little unsatisfying to get numerical errors, but machines don’t do exact computation easily. We’re interested in getting as close as we need to get without doing a lot of work that would, in the end, never make a difference. The operating principle here is that we need to be sure that our code is doing what we think it should, and that it is giving answers that are close enough. "],["2.2-sdtsRoss.html", "2.2 Stochastic, Discrete Time", " 2.2 Stochastic, Discrete Time Demographic stochasticity. If we followed individuals in a population that followed the simple rules described in Equation (2.1) and Equation (2.2), we would like to be able to understand how they are connected to the deterministic equations we developed in Section-2.1. Setting aside the problems that get introduced by sampling populations for the moment – we will pretend we’re omniscient – we would find random changes occurring: individual humans would be switching states over time at random: from infected to uninfected and back; individual mosquitoes would be dying at random: infected mosquitoes would get replaced by uninfected mosquitoes, and uninfected mosquitoes would be blood feeding and getting infected if they blood fed on an infected (and infectious) human. The world really has a random component to it. It is not deterministic but stochastic. In the deterministic models that we called ross_dts_1 and ross_dts_2, the values of each variable at each point in time were specified exactly by the equations, the rules for updating the variables each day. The values of the variables were proportions, which is related to the metric prevalence. In these models, the variables asymptotically approach a steady state. Once at the steady state, the fractions infected would never change. In models with stochasticity, we could use the same exact rules to specify what is expected to happen, but we must draw a random number to determine the values of the variables. To do this, we want to be working with the counting numbers – the number of humans in a population and the number of those humans who are infected; and the number of mosquitoes in a population, and the number of those mosquitoes who are infected. The variability in the values of our variables over time due to the random component of parasite infection dynamics – also called the parasite demographics – would be called demographic stochasticity. The model has some things in common with the ones we described above: the model doesn’t have a steady state, but there is something like a steady state that the variables fluctuate around. We’ll call it an attractor. The variables are always pulled towards the attractor, but the values of the variables are constantly changing around it. In a real study, we can’t pretend to be omniscient, but we will discuss that later. Parameters – We can use the same parameters as before, but there are two new parameters: \\(M\\) is the number of mosquitoes: \\(M\\) is a counting number \\(H\\) is the number of humans; \\(H\\) is a counting number Otherwise we use the same parameters as we did before. # The parameters, as a list ross_sdts_par = list( M = 50, # The number of mosquitoes H = 100, # The number of humans s = 1/200, # The fraction of infections that clear each day u = 1/12, # The fraction of mosquitoes that die each day a = 1/4 # The fraction of mosquitoes that blood feed on a human each day ) ross_sdts_par$m = with(ross_sdts_par, M/H) Variables In the stochastic model, our variables are counting numbers, not fractions: \\(Y \\leq M\\) is the number of infected mosquitoes: \\(Y\\) is a counting number \\(X \\leq H\\) is the number of infected humans: \\(X\\) is a counting number It is easy enough to define prevalence: \\(x = X/H\\) is malaria prevalence in humans; the fraction of humans infected \\(y = Y/M\\) is malaria prevalence in mosquitoes; the fraction of mosquitoes infected Equations Now we have got to describe a stochastic process. Each individual changes state with some probability. Each one is a Bernoulli random variable, and the appropriate proability mass function is the binomial model. In R, we use the built-in function rbinom(1, N, p) to draw one random variable on \\(N\\) individuals that remains in the same state with probability \\(p\\). In each step, there are four possible changes, depending on the states: \\(X\\) - if humans are infected today, they might lose infection. An infection is lost with probability \\(s\\), so the fraction that remain infected is \\(1-s.\\) The number that remains infected is rbinom(1, X, 1-s). \\(H-X\\) - if humans are uninfected today, they might get infected. The probability of getting infected is called the daily attack rate. The expected number of infected bites is \\(aY/H\\), and if we use the Poisson to model the distribution of bites per person, then the attack rate is \\(1-e^{-aY/H}\\). The number that remains ends up infected is rbinom(1, H-X, ar). \\(Y\\) - if mosquitoes are infected today, they might die. The fraction dying is \\(u\\), so the number of surviving infected mosquitoes is rbinom(1, X, 1-s). \\(H-Y\\) - if mosquitoes are uninfected today, they might get infected. To get infected, a mosquito must blood feed on an infected human, so the fraction getting infected is \\(aX/H\\). The number that gets infected is rbinom(1, H-Y, a X/H). The rule for updating the number of infected humans and mosquitoes is thus: \\[\\begin{equation} \\begin{array}{rl} X_{t+1} &amp;= \\mbox{Binom}(X, 1-s) + \\mbox{Binom}(H-X, 1-e^{-a Y/H}) \\\\ Y_{t+1} &amp;= \\mbox{Binom}(Y, 1-u) + \\mbox{Binom}(M-Y, aX/H) \\\\ \\end{array} \\end{equation}\\] The following implements this as R code: # XY - a vector of the form c(t, X, Y) # params - the parameters, as a list ross_sdts = function(XY, params){ with(as.list(XY), with(params,{ ar = 1 - exp(-a*Y/H) Xn = rbinom(1, X, 1-s) + rbinom(1, H-X, ar) Yn = rbinom(1, Y, 1-u) + rbinom(1, M-Y, a*X/H) t=t+1 return(c(t=t, X=Xn, Y=Yn)) }))} We write a wrapper that solves it: # INPUTS # pars - the parameters, as a list # X0 - the initial number of infected humans # Y0 - the initial number of infected mosquitoes # t0 - the initial value of t # tmax - the last value of t # # OUTPUTS # the values of the variables over time, as a list sim_ross_sdts = function(pars, X0=2, Y0 = 1, t0=0, tmax=100){ XY = c(t=t0, X=X0, Y=Y0) XY_t = XY for(t in (t0+1):tmax){ XY = ross_sdts(XY, pars) XY_t = rbind(XY_t, XY) } X=XY_t[,2] Y=XY_t[,3] x=X/pars$H y=Y/pars$M return(list(time=XY_t[,1], x=x, y=y, X=X, Y=Y, last = XY)) } We can write another function that plots the equations (i.e. that iteratively computes and stores the values) over some time interval: # INPUTS # XY_t - a list with elements named x, y, and time # type - plot type: &quot;l&quot; or &quot;p&quot; or &quot;b&quot; # lty - lty # add - if TRUE, add to existing plot plot_XY = function(XY_t, type=&quot;l&quot;, lty=1, add= FALSE){with(XY_t,{ if(add == FALSE) plot(time, X, type = &quot;n&quot;, ylim = range(0, X, Y), ylab = &quot;Number Infected&quot;, xlab = &quot;Time&quot;) lines(time, X, type=type, lty=lty, col=&quot;darkgreen&quot;, pch =15) lines(time, Y, type=type, lty=lty, col=&quot;darkorange&quot;, pch =19) text(0, 0.9*max(X,Y), &quot;X&quot;, col = &quot;darkgreen&quot;, pos=4) text(0, 0.8*max(X,Y), &quot;Y&quot;, col = &quot;darkorange&quot;, pos=4) })} A useful feature of R is the ability to replicate any particular sequence of random numbers by setting a seed. This also makes it easy to write a book knowing what the random number sequence will be. set.seed(253) XYt &lt;- sim_ross_sdts(ross_sdts_par, tmax=300) plot_XY(XYt) Once we’re close to the steady state, some time after the first 100 days, we can compute the mean: Xdist= with(XYt, X[-c(1:100)]) Ydist= with(XYt, Y[-c(1:100)]) mX = mean(Xdist) mY = mean(Ydist) c(X=mX, Y=mY) ## X Y ## 95.10945 36.26866 This can be visualized as a histogram: par(mfrow=c(1,2)) hist(Xdist, xlab = &quot;x&quot;, main = &quot;X, for t&gt;100&quot;) segments(mX, 0, mX, 250, lwd=4, col = &quot;darkgreen&quot;) hist(Ydist, 15, xlab = &quot;y&quot;, main = &quot;Y, for t&gt;100&quot;) segments(mY, 0, mY, 200, lwd=4, col = &quot;darkorange&quot;) Since we can compute prevalence, we can plot it out: plot_xy(XYt) xdist= with(XYt, x[-c(1:100)]) ydist= with(XYt, y[-c(1:100)]) mx = mean(xdist) my = mean(ydist) c(x=mx, y=my) ## x y ## 0.9510945 0.7253731 par(mfrow=c(1,2)) hist(xdist, xlab = &quot;x&quot;, main = &quot;x, for t&gt;100&quot;) segments(mx, 0, mx, 250, lwd=4, col = &quot;darkgreen&quot;) hist(ydist, 15, xlab = &quot;y&quot;, main = &quot;y, for t&gt;100&quot;) segments(my, 0, my, 200, lwd=4, col = &quot;darkorange&quot;) The system still tends towards a point – we’ll call it an attractor and not a steady state. The values of \\(X\\) and \\(Y\\) (or of \\(x\\) and \\(y\\)) fluctuate around that steady state. Since the counting number values get repeated, we can illustrate what the cloud looks like by jittering the locations of the points: with(XYt,{ ix = which(time&gt;100) plot(jitter(X[ix]), jitter(Y[ix]), xlab = &quot;X&quot;, ylab = &quot;Y&quot;) }) points(mX, mY, col = &quot;darkred&quot;, pch = 8, cex =3) We note that mean prevalence is very close to the steady state of the deterministic system with the same parameter values: c(mx, my) - ross_dts_steady_2(ross_sdts_par) ## [1] 0.004686644 -0.014157539 An important feature of stochastic systems is that it is possible for the parasite to randomly fade out, if at any time \\(X=Y=0.\\) This is something we’d like to take a bit more time computing. "],["2.3-xdeRoss.html", "2.3 Deterministic, Continuous Time", " 2.3 Deterministic, Continuous Time Differential equations. In this section, we present a basic, deterministic, continuous-time model. After seeing the ross_dts models, this model will look and feel familiar. Instead of describing a difference over a fixed time step, we describe a derivative. The idea of derivative is usually introduced as the second new concept in any introduction to calculus. Instead of describing the fraction of a population that changes over any fixed time interval, the derivative describes change over an interval of time that is infinitesimally small. To understand differential equations, you will need a background in calculus. If you’ve had a semester of calculus, you will have come across derivatives. Depending on how much calculus, you might not have solved differential equations. The point of this book is to introduce malaria analytics, so we will not be delving into mathematical theory or numerical methods very much. In discrete-time, the equations could be written in this form: \\[ \\begin{array}{rl} x_{t+1} - x_t &amp;= F_x (x_t, y_t) \\\\ y_{t+1} - y_t &amp;= F_y (x_t, y_t) \\\\ \\end{array} \\] The left hand side says “the difference in” \\(x\\) or \\(y\\) “over one time step is equal to” \\(F_x\\) or \\(F_y,\\) which are functions of the two variables. We can now ask what would happen if we sub-divided a day into \\(n\\) equal periods. In the limit as \\(n\\) goes to infinity, we replace the differences (terms on the left hand side) with derivatives. The differential equations are now written in this form: \\[ \\begin{array}{rl} \\frac{\\textstyle{dx}}{\\textstyle{dt}} &amp;= F_x (x, y) \\\\ \\frac{\\textstyle{dy}}{\\textstyle{dt}} &amp;= F_y (x, y) \\\\ \\end{array} \\] These differential equation models have the same components as the difference equations: variables, initial conditions, and parameters. To compute anything, we will need to use numerical methods. Fortunately, R has a package to handle numerical methods for differential equations, called deSolve. library(deSolve) Here, we present and solve ross_xdea continuous time, deterministic model that is similar to Ross’s 2nd model [1]. 2.3.1 ross_xde Variables – In ross_xde, the dependent variables have the same meaning as in the ross_dts equations, but the independent variable. We now write an equation describing the fraction of humans and mosquitoes that are infected at each point in time. Let \\(x(t)\\) be the fraction of people who are infected at time \\(t,\\) and \\(0 \\leq x(t) \\leq 1.\\) Let \\(y(t)\\) be the fraction of mosquitoes who are infected at time \\(t,\\) \\(0 \\leq y(t) \\leq 1.\\) Initial Conditions – As before, we will need to define initial conditions. ross_xde_inits = c(x=0.01, y=0.01) Parameters – In this model, the parameters describe rates of change. Let \\(r\\) denote the fraction of people who clear infections after one day; \\(0 &lt; r &lt; 1.\\) Let \\(g\\) denote the fraction of mosquitoes who die in one day; \\(0 &lt; g &lt; 1.\\) Let \\(a\\) denote the fraction of mosquitoes who blood feed on a human in a day; \\(0 &lt; a &lt; 1.\\) Let \\(m\\) denote the number of mosquitoes per human; \\(m \\geq 0.\\) # The parameters, as list ross_xde_par = list( r = 1/200, # The clearance rate for infections g = 1/12, # The mosquito daily death rate a = 1/4, # The mosquito human blood feeding rate m = 0.5 # The number of mosquitoes per human ) Equations – Finally, we put all this together into a mathematical statement that has translated the description of a process. There are four terms: The fraction of humans who are infected is \\(x\\); infections clear at the rate \\(r.\\) The fraction of mosquitoes who are infected is \\(y\\); mosquitoes die at the rate \\(g.\\) The fraction of humans who are not infected is \\(1-x\\); infections occur at the rate \\(m a y.\\) The fraction of mosquitoes who are not infected is \\(1-y\\); infections occur at the rate \\(a x.\\) \\[ \\begin{array}{rl} dx/dt &amp;= may(1-x) - r x\\\\ dy/dt &amp;= ax(1-y) - g y \\\\ \\end{array} \\] The form of the function that computes the derivatives in R is defined by deSolve # INPUTS # t - the current time # vars - the variables, as a named vector # pars - the parameters, as a list # OUTPUTS # the derivatives, as a list ross_xde = function(t, vars, pars){ with(pars, with(as.list(vars),{ dxdt = m*a*y*(1-x) - r*x dydt = a*x*(1-y) - g*y return(list(c(dxdt, dydt))) }) ) } 2.3.2 Rates vs. Proportions The rates in differential equations can be compared to the proportions in discrete time systems. When the rates describe a change of state, a loss term for one of the variables, there are two easy interpretations. First, we consider the rate of loss of infected humans in a population, \\(-rx.\\) The core underlying process is exponential decay. If we followed a cohort, the waiting time for an individual to change states would follow an exponential distribution with rate \\(1/r\\). Second, after one day, the fraction that remains infected is \\(e^{-r}\\). If we set \\(r=1/200,\\) for example, the expected waiting time to clear an infection is 200 days. The rate of loss after one day is very close to, but slightly less than \\(r\\): c(1/200, 1-exp(-1/200)) ## [1] 0.005000000 0.004987521 2.3.3 Solutions We now want to solve the initial value problem: given \\(x(0)\\) and \\(y(0),\\) can we find solutions \\(x(t)\\) and \\(y(t)\\)? To do so, we call deSolve::ode, which takes for arguments: the initial values, the points in time to ouput values of \\(x(t)\\) and \\(y(t)\\), a function that computes the derivatives, and the parameters: deSolve::ode(ross_xde_inits, 0:5, ross_xde, ross_xde_par) ## time x y ## 1 0 0.01000000 0.01000000 ## 2 1 0.01128886 0.01172469 ## 3 2 0.01279276 0.01363682 ## 4 3 0.01453497 0.01577333 ## 5 4 0.01654339 0.01817408 ## 6 5 0.01884959 0.02088053 2.3.4 Computation &amp; Visualization For easy in working with these equations, we write a wrapper: # INPUTS: # pars -- the parameter values, as a list # x0 -- the initial value for x(t) # y0 -- the initial value for y(t) # tmax -- the largest value of t # dt -- the interval for t # OUTPUT: # the output of ode as a data.frame ross_xde_solve = function(pars, x0=.01, y0=0.001, tmax=100, dt=1){ tms = seq(0, tmax, by = dt) xy0 = c(x=x0, y=y0) data.frame(ode(xy0, tms, ross_xde, pars)) } deout &lt;- ross_xde_solve(ross_xde_par) Because we have returned it as a data frame, the column names are time and x and y. We can plot the values using with(). plot_xy(deout) These differential equations require 2.3.5 Steady States We can learn a bit more about how these equations behave by changing the initial values: deout1 &lt;- ross_xde_solve(ross_xde_par, x0=0.2, y0=0.02) deout2 &lt;- ross_xde_solve(ross_xde_par, x0=.99, y0=0.99) plot_xy(deout) plot_xy(deout1, lty=2, add=TRUE) plot_xy(deout2, lty=3, add=TRUE) We notice that the orbits all asymptotically approach the same values, regardless of where they started. Once there, they stay there. 2.3.6 Verification We ought to be able to compute the value of these steady states: it is a value of \\(x(t)\\) and \\(y(t)\\) such that \\(dx/dt=dy/dt=0.\\) To find it, we set \\(dx/dt=dy/dt=0\\) and solve for \\(x\\) and \\(y.\\) One obvious value, once again, is \\(x=y=0.\\) \\[ \\begin{array}{rl} 0 &amp;= may(1-x) - r x\\\\ 0 &amp;= ax(1-y) - g y \\\\ \\end{array} \\] Solve the second equation for \\(y\\) \\[y = ax/(g+ax)\\] Substitute back into the first equation: \\[ma^2 (1-x) = r(g+ax)\\] and solve. \\[x = \\frac{\\textstyle{m a^2 - rg}}{\\textstyle{m a^2 + ra}}\\] Noting that \\(m a^2 &gt; rg\\) must be a threshold condition, we write a function to compute the steady state using the formula we just derived: ross_xde_steady_1 = function(pars){with(pars,{ xx = ifelse(m*a^2 &gt; r*g, (m*a^2 - r*g)/(m*a^2 + r*a), 0) yy = a*xx/(g+a*xx) c(x=xx, y=yy) })} ross_xde_steady_1(ross_xde_par) ## x y ## 0.9487179 0.7400000 We check it against the other way, which involves running the system for a very long time. de_eq &lt;- ross_xde_solve(ross_xde_par, tmax=500, dt=5) with(de_eq, c(x=tail(x,1), y=tail(y,1))) ## x y ## 0.9487179 0.7400000 2.3.7 Thresholds write me. References "],["2.4-sxdeRoss.html", "2.4 Stochastic, Continuous Time", " 2.4 Stochastic, Continuous Time In continuous time, the state of the system is updated one event at a time. The total rate of change of the system is \\(T = may(H-X) + rX + aX(M-Y) + gY\\) \\(Y \\rightarrow Y+1\\) \\(Y \\rightarrow Y-1\\) \\(X \\rightarrow X+1\\) \\(X \\rightarrow X-1\\) # The parameters, as list ross_sxde_par = list( r = 1/200, # The clearance rate for infections g = 1/12, # The mosquito daily death rate a = 1/4, # The mosquito human blood feeding rate M = 50, # The number of mosquitoes H = 100 # The number of humans ) ross_sxde = function(XY, pars){ with(as.list(XY), with(pars,{ p1 = a*Y*(H-X)/H p2 = r*X p3 = a*X*(M-Y)/H p4 = g*Y t = t + rexp(1, p1+p2+p3+p4) event = sample(1:4, 1, prob=c(p1, p2, p3, p4)) if (event==1) X &lt;- X+1 if (event==2) X &lt;- X-1 if (event==3) Y &lt;- Y+1 if (event==4) Y &lt;- Y-1 return(c(t=t, X=X, Y=Y, x=X/H, y=Y/M)) }))} xy = c(t=0, X=10, Y=10) for (i in 1:5){ xy &lt;- ross_sxde(xy, ross_sxde_par) print(xy) } ## t X Y x y ## 0.3400889 11.0000000 10.0000000 0.1100000 0.2000000 ## t X Y x y ## 0.3675833 12.0000000 10.0000000 0.1200000 0.2000000 ## t X Y x y ## 0.4201633 12.0000000 9.0000000 0.1200000 0.1800000 ## t X Y x y ## 0.7824542 13.0000000 9.0000000 0.1300000 0.1800000 ## t X Y x y ## 1.072306 14.000000 9.000000 0.140000 0.180000 sim_ross_sxde = function(pars, X0=2, Y0=1, tmax=300){ XY = c(t=0, X=X0, Y=Y0) tm = XY[1] XY_t = c() while(tm &lt; tmax){ XY = ross_sxde(XY, pars) tm = XY[1] XY_t = rbind(XY_t, XY) } return(list(time=XY_t[,1], X=XY_t[,2], Y=XY_t[,3], x = XY_t[,4], y = XY_t[,5])) } out &lt;- sim_ross_sxde(ross_sxde_par) par(mfrow = c(2,1)) plot_XY(out) plot_xy(out) par(mfrow=c(1,2)) with(out,{ ix = which(time&gt;100) xdist= X[ix]; mx = mean(xdist) ydist= Y[ix]; my = mean(ydist) hist(xdist, 10, xlab = &quot;X&quot;, main = &quot;X, for t&gt;100&quot;) segments(mx, 0, mx, 250, lwd=4, col = &quot;darkgreen&quot;) hist(ydist, 15, xlab = &quot;Y&quot;, main = &quot;Y, for t&gt;100&quot;) segments(my, 0, my, 200, lwd=4, col = &quot;darkorange&quot;) }) If we want to compare it to the other model, we can compute prevalence: par(mfrow=c(1,2)) with(out,{ ix = which(time&gt;100) xdist= x[ix]; mx = mean(xdist) ydist= y[ix]; my = mean(ydist) hist(xdist, 10, xlab = &quot;x&quot;, main = &quot;x, for t&gt;100&quot;) segments(mx, 0, mx, 250, lwd=4, col = &quot;darkgreen&quot;) hist(ydist, 15, xlab = &quot;y&quot;, main = &quot;y, for t&gt;100&quot;) segments(my, 0, my, 200, lwd=4, col = &quot;darkorange&quot;) }) "],["2.5-mathSpecies.html", "2.5 Mathematical Species", " 2.5 Mathematical Species What species of mathematics is best suited for a task? Does it matter what species of mathematics we choose to build our models? As we use models to help us understand malaria in some particular place, we are faced with some questions about to interpret the outputs of models. One of the reasons we presented deterministic and stochastic models in discrete-time and in continuous-time was to learn about about modeling by drawing attention to some of the differences – the models all represent the same process, but the outputs differ. Some of these differences are unsurprising and probably not important, but if we are to learn how to critically evaluate a model, we must pay attention to these differences. s 2.5.1 Deterministic Models In the deterministic models, the variables over time are repeated in exactly the same way. If we changed a parameter or an initial condition, we would of course get different orbits. The discrete-time and continuous-time models differ slightly from each other. Some small differences will persist because we are dealing with non-linear processes. In the following, we have plotted the outputs of all three deterministic models, and the differences between the continuous time and the two discrete-time models (bottom). The main difference between the two models is that malaria prevalence increases more slowly in the discrete-time models. The model ross_dts_1 is slightly closer to the continuous time model. How different are these two models? We could develop a formal distance metric to compare two models. First, since the variables in the continuous-time model is defined for every value of \\(t\\), but the discrete-time model is defined only for integer values of \\(t\\), we can only make comparisons for integer values of \\(t.\\) In the simulations above, we took care to output the values of both models at the same time points, so we can simply take the sum of squared differences: ssd_2mods = function(m1, m2, norm=1){ dx = sum((with(m1, x) - with(m2, x))^2) dy = sum((with(m1, y) - with(m2, y))^2) return((dx+dy)/norm) } ssd_2mods(r_xde, r_dts, norm = length(r_xde$time)) ## [1] 0.0003286306 Or the sub of their absolute values of the differences: sabs_2mods = function(m1, m2, norm=1){ dx = sum(abs(with(m1, x) - with(m2, x))) dy = sum(abs(with(m1, y) - with(m2, y))) return((dx+dy)/norm) } We can interpret this to mean that the average sum of differences is about 1.6% sabs_2mods(r_xde, r1_dts, norm = length(r_xde$time)) ## [1] 0.008878746 2.5.2 Stochastic Models In stochastic models, the values of the variables differ each time we run the model. "],["2.6-notes.html", "2.6 Notes", " 2.6 Notes The Reed-Frost model The chain-binomial model "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
