---
output:
  pdf_document: default
  html_document: default
---
# Basic Malaria Models 

*Basic malaria models as deterministic or stochastic systems of difference or differential equations* 

*** 

1. Section \@ref(dtsRoss) presents a basic deterministic discrete-time system. 

2. In Section \@ref(basicComputation), we discuss some basic issues about computation.  

3. In Section \@ref(countingEvents), we show that the model presented in Section \@ref(dtsRoss) is numerically unstable. We discuss the history of discrete-time systems in epidemiology. We introduce the Poisson distribution, and we use it to develop a new model that is numerically stable.  

4. Section \@ref(sdtsRoss) presents a stochastic discrete-time system; 

5. Section \@ref(xdeRoss) presents a deterministic continuous-time system; 

6. In Section \@ref(sxdeRoss), we present a stochastic process in continuous-time; 

7. In Section \@ref(mathSpecies), we compare and contrast discrete *vs.* continuous, and deterministic *vs.* stochastic models. 

In this chapter, we're not trying to delve too deeply into malaria epidemiology. 
Instead, this chapter is about trying to develop basic skills that will be a foundation for model building.
Our goals are thus to learn the basic elements of different kinds of models, and to develop some basic intuition about the different kinds of models that exist, and how we can think about models as approximations.
Each model is implemented as R code^[In developing this book, we assumed the reader would be familiar with R and RStudio.]

We assume that the gentle reader has some basic familiarity with these concepts in the next chapter, when we present [The Ross-Macdonald Model]. 

## Ross's Quantiative Logic 

As Ross was planning malaria control activities, he sought to develop mathematics for support malaria control planning. 
He was looking for a way of setting rational expectations about the likely outcomes of control.
Given his interests in malaria metrics, he sought to understand why malaria prevalence differed from place to place.
To explain these differences, so he developed mathematical models that described infection and the loss of infection, the processes affecting how malaria prevalence would change over time. 

Malaria infections in two host populations -- humans and mosquitoes -- are connected through mosquito blood feeding, so malaria transmission works as an integrated system. The process looks something like the following diagram.

***

![**Infection Dynamics** -- The parasite life-cycle involves a dynamic process in two host populations, and it requires blood meals. Uninfected mosquitoes get infected when they take up parasites after blood feeding on an infected human. Uninfected humans become infected by the mosquitoes transmitted in saliva when a mosquito bites, prior to blood feeding. ](Figures/LifeCycleModel.png)

***

This graph is the basis for causal theory for malaria parasite propagation in populations, but students of causation might object that the graph describes a cycle and thus it can not be causal. 
If we applied the logic more generally, no graph describing any organisms life cycle would be causal, and yet life is undoubtedly the cause of life.
The missing element is time: a life-cycle graph would be directed and acyclic if it had an arrow that traced life in one generation giving rise to life in the next.
To understand this as a causal diagram, we must thus imagine that it describes a dynamical process in populations: infected mosquitoes today are biting and infecting humans tomorrow; and infectious humans today are causing infections in mosquitoes tomorrow when they take a blood meal. 
Seen in this way, we can begin to develop a quantitative theory that describes all the factors that determines malaria prevalence in populations.
How does malaria persist in a population? 
It persists through the transmission of parasites among hosts during blood feeding.
What factors determine prevalence?
It is a balance between the gain and loss of infection.

To develop a mathematical model, Ross believed that it was possible to write down *a priori* -- or in other words, to formulate mathematical models using quantitative logic -- a description of the process. 
To write down the model, we must make some assumptions about the process.
We begin with an abstract concept of place -- *here.* 
We imagine that populations here are comprised of individual mosquitoes and individual humans, and we are interested in computing the fractions of humans and mosquitoes that are infected. 
Since infections don't last forever, the prevalence of infection in mosquitoes and humans reflects a balance between infections acquired through parasite transmission and the natural loss of infection through parasite clearance or host mortality.
In many places, forces affecting the the balance can be changing; mosquito population density fluctuates over time, for example.
Ross's equations assumed that transmission by mosquitoes was constant over time, and they focused on *local* transmission, ignoring exposure elsewhere (*e.g.* through travel). 
This model thus ignores many factors that would be important for planning for control. Ross discussed all these factors, but since he was pioneering a new approach, the models were very simple.

Mosquitoes lived short lives, so the loss of parasites in mosquitoes would mainly occur through mosquito mortality: 

\begin{equation}
\mbox{MOSQUITOES} 
\\ \; \\
\left[
\begin{array}{rcl}
\mbox{Infected Tomorrow} &=& \mbox{Infected Today} \\
&-&\mbox{Infected: Died}\\
&+&\mbox{Uninfected: Got Infected}\\
\end{array} \right]
(\#eq:Mprocess)
\end{equation}


This description of a process ignores the loss of infection in mosquitoes, and changing mosquito population density. 
It ignores the *extrinsic incubation period* (EIP), the lag between the point in time when a mosquito gets infected and when it becomes infectious. 
This basic description of the process does not explicitly address the process that gives rise to uninfected mosquitoes. 
The mathematical formulation implies, without stating it explicitly, that each dying infected mosquito gets replaced by an uninfected mosquito emerging from an aquatic habitat. 
Otherwise, the mosquito population would declining over time.
Ross was interested in malaria transmission dynamics, so the mosquito ecology was almost invisible.  

Humans live long lives, so parasite loss would mainly occur through natural clearance.  

\begin{equation}
\mbox{HUMANS} 
\\ \; \\
\left[
\begin{array}{rcl}
\mbox{Infected Tomorrow} &=& \mbox{Infected Today} \;\; \\
&-& \mbox{Infected: Cleared Infection}\\
&+& \mbox{Uninfected: Got Infected}\\
\end{array} \right]
(\#eq:Hprocess)
\end{equation}

This description of the process thus ignores human demography, including births, deaths, and migration. The model also ignores a large number of other factors, including superinfection, the complex time course of an infection, immunity, and treatment with anti-malarial drugs. (In Ross's day, quinine was expensive and difficult to obtain, but it was sometimes used.) 

To describe malaria transmission and factors that determine the prevalence of malaria in human populations over time, we formulate mathematical models as dynamical systems.
In the sections that follow, we will formulate dynamical systems in discrete and continuous time, and as a deterministic or stochastic processes.

As a reminder, we're not trying to delve too deeply into malaria epidemiology with the models in this chapter.
Instead, this chapter is about trying to develop a toolbox that we can use to investigate malaria transmission dynamics and control. 

Later, we will start using some R packages that were developed to support robust analytics for malaria policy.
Later, we'll worry about modifying the assumptions to ensure that we are dealing with the issues that matter for in malaria policy. 

## Deterministic, Discrete-Time {#dtsRoss}

*The parts of a model: variables, parameters, initial conditions.* 

*** 
In this section, we present the basic, deterministic, discrete-time model for a mosquito-transmitted pathogen. Because it is the first model in the book, we'll take the time to explain some background material in detail. We'll discuss the parts of a model, and we walk through the process of solving models. 

### Model 

We will present the parts of the model first, and write down the equations last. The parts of a model are called parameters and variables. To solve the model, we will need initial conditions for the variables. As we go, we will also write R code that implements the model and that solves it. In writing the code, we will adopt some conventions that we can use to help us write good code. 

**Variables** are quantities that describe the state of a system. 
One variable in this model is time, denoted $t.$ 
The *dependent variables* are the quantities that we want to compute, and they are 
computed at various time points. Time is marching forward, unaffected by the dependent variables, so we call it the *independent variable.* 

In this model, there are two dependent variables: the proportion of humans and mosquitoes that are infected at each point in time. Since it is a discrete time system, the values of the variables are defined only at integer values of $t.$ We define the variables as follows:

+ let $t$ represent time, in days;

+ let $x_t$ be the fraction of people who are infected at time $t,$ and $0 \leq x_t \leq 1;$

+ let $y_t$ be the fraction of mosquitoes who are infected at time $t,$ $0 \leq y_t \leq 1.$ 

Another term for the fraction of a population that infected with parasites is *prevalence.* 

**Initial Conditions** are the values of the variables at one point in time. Since the values of our variables in the next time step (at time $t+1$) depend on their values now (at time $t$), we can't really compute anything specific unless we specify the values of the variables at one point in time. Having set one set of values, we can use the equations to compute the rest.  

The initial conditions specify the values of all our variables at the beginning of the simulation. By convention, this is usually at time $t=0,$ but we could also specify their values at any other point in time. 

We can now begin to write R code to set up the objects so we can compute them. We set these initial values to be small: 

```{r, echo=TRUE}
# Initial Conditions at a point in time, as a Named Vector 
xy = c(t=0, x=0.01, y=0.001)
xy
```

In R, this object `xy` is called a *named vector.* The names that appear above the numbrers are carried along but they don't affect the values of any computation done with `xy.` It is also useful that the names often get inherited (but not always). The names can be used as names using the function `as.list()` or `data.frame().` 

```{r, echo=TRUE}
as.list(xy)$x
```

When combined with the `with()` function, we can create a context where we can call them by name: 

```{r, echo=TRUE}
with(as.list(xy), x) 
```

This code has adopted the convention of using named vectors so that we can write functions in a way that is easy to read. It also makes it easier to deal with the model outputs. 

**Parameters** are quantities -- rates, numbers, or probabilities -- that describe some part of the process. Unlike variables, parameter values are chosen outside of a model and passed to it. In `ross_diffs_1,` these parameters are constant. Since they are constant, we call this an *autonomous* system of equations. In other models, we could have parameter values that changes over time, so the system would be called *non-autonomous.*

The parameters in this model define changes in prevalence: the fraction of humans that clear an infection each day; the fraction of infected mosquitoes that die; and blood feeding and infection. 

  + Let $s$ denote the fraction of people who clear infections after one day; $0 < s < 1.$ 

  + Let $u$ denote the fraction of mosquitoes who die in one day; $0 < u < 1.$ 

  + Let $a$ denote the fraction of mosquitoes who blood feed on a human in a day; $0 < a < 1.$ 

  + Let $m$ denote the number of mosquitoes per human; $m \geq 0.$ 

```{r, echo=TRUE}
# Make a valid parameter set, as a list 
ross_dts_make_par = function(
  s = 1/200, # The fraction of infections that clear each day
  u = 1/12,  # The fraction of mosquitoes that die each day
  a = 1/4,   # The fraction of mosquitoes that blood feed on a human each day
  m = 2      # The number of mosquitoes per human
){
  list(s=s, u=u, a=a, m=m)
}
```


```{r, echo=TRUE}
ross_dts_par = ross_dts_make_par()
```

**Equations** describe dynamic changes in the variables over time. In this case, the process is described by a system of coupled difference equations. 

Finally, we put all this together into a mathematical statement that has translated the description of a process, that are describe the process. 

\begin{equation}
\begin{array}{rl}
x_{t+1} &=  x_t - s x_t + m a y_t (1-x_t)  \\ 
y_{t+1} &=  y_t - u y_t + a x_t (1 - y_t) \\ 
\end{array}
(\#eq:ross1a)
\end{equation}

We could rewrite the equations to make it easier to interpret them. 

\begin{equation}
\begin{array}{rl}
x_{t+1} - x_t &=  - s x_t + m a y_t (1-x_t)  \\ 
y_{t+1} - y_t &=  - u y_t + a x_t (1 - y_t) \\ 
\end{array} 
(\#eq:ross1b)
\end{equation}

In this alternative way of writing down the equations, the left hand side is interpreted as *the daily change,* and the terms on the right hand side describes those changes. The RHS has four terms: 

+ $- s x_t$ -- is a decrease in the prevalence of human malaria infections caused by clearance of human infections: the fraction of humans who are infected is $x_t$; a fraction $s$ clears infections each day.
    
+ $+ may_t (1-x_t)$ -- is an increase in the prevalence of human malaria infections caused by the bites of infectious mosquitoes: the fraction of humans who are not infected is $1-x_t$; a fraction $m a y_t$ gets infected. 

+ $-u y_t$ -- is a decrease in the prevalence of mosquito malaria infections caused by mosquito mortality: the fraction of mosquitoes who are infected is $y_t$; a fraction $u$ die. 
    
+ $+ a x_t (1-y_t)$ -- is an increase in the prevalence of mosquito malaria infections caused blood feeding on an infected human: the fraction of mosquitoes who are not infected is $1-y_t$; a fraction $a x_t$ blood feeds on an infected human and gets infected. 

To foreshadow something we will address in sub-section \@ref(dtsRoss2), if $may_t >1,$ then it is not a proportion, and the equations don't make sense. 

***

To update the variables, we write a function in R. Since we will be developing a lot of functions and models, we adopt a simple naming convention: since it was developed by Ross, we attach the stem `ross`; since this is a discrete time system, we attach the suffix `dts`; we might want to generate other variants, so we append a number. The function is thus called `ross_diffs_1.` 

```{r, echo=TRUE}
# INPUTS
# xy     - current variables, as a named vector
# params - the parameters, as a list
#
# OUTPUTS
# the updated values of the variables, as a named vector

ross_diffs_1 = function(xy, params){
  with(as.list(xy), 
    with(params,{
      xn = x - s*x + m*a*y*(1-x) 
      yn = y - u*y + a*x*(1-y) 
      return(c(t=t+1, x=xn, y=yn))
    })
  )
}
```

### Solutions 

With the R code we developed, we can *solve* the equations, which involves computing the values of the variables iteratively. Since the values of the variables change, we create another object `xy_t` that we can use to store the values of computed variables over time. 

```{r, echo=TRUE}
# xy_t stores the values of the variables
xy_t = xy
xy_t
```

We iterate in two steps. First, we compute the values. 

```{r, echo=TRUE}
# Compute 
xy = ross_diffs_1(xy, ross_dts_par)
```

Since we initialized the system at time $t=0,$ the following computes the values of the parameters at time $t=1.$ We can take a peak at the values we computed: 

```{r, echo=TRUE}
# Print to screen
print(xy) 
```

Next, we store the values using `rbind`

```{r, echo=TRUE}
# Store 
xy_t = rbind(xy_t, xy)
```
We can take a peak: 

```{r, echo=TRUE}
# Print to screen
print(xy_t) 
```

We can iterate over many time steps, each time storing the values:

```{r, echo=TRUE}
# Iterate to compute the values as they change over time 
for(t in 2:40){
  xy = ross_diffs_1(xy, ross_dts_par) 
  xy_t = rbind(xy_t, xy) 
} 
```

We can look at the last few values, the values of $t,$ $x$ and $y$ are stored in columns: 

```{r, echo=TRUE}
print(tail(xy_t, 3)) 
```

As we can see, the values are changing a little at the end. 



Notice that after 40 days, the values of $x$ and $y$ appear to be approaching some value asymptotically. This is an important feature of these systems, one that we would like to understand and explore a bit more in the following sections. 

 
### Analysis

#### Steady States 

The fact that our variables asymptotically approach some values over time is an important feature of dynamical systems, so we would like to do some analysis to understand it better. If we look at Eq. \@ref(eq:ross1b), we can understand why. In this model, there is no change when the proportion of humans becoming infected is equal to the proportion clearing infections; and the proportion of mosquitoes becoming infected is equal to the proportion dying. 

In the following, we compute how much the system is changing over time. We can simply iterate once and compare the differences. After iterating 40 times, the differences are very small: 

```{r, echo=TRUE}
# The last value is still stored as xy; the [-1] omits t
xy[-1] - ross_diffs_1(xy, ross_dts_par)[-1]
```

If we iterate another hundred days and check again, the differences have gotten even smaller: 

```{r, echo=TRUE}
for(i in 41:140){
  xy = ross_diffs_1(xy, ross_dts_par)
  xy_t = rbind(xy_t, xy) 
} 
xy[-1] - ross_diffs_1(xy, ross_dts_par)[-1]
```

After simulating, the variables reach a steady state, where asymptotically $x_{t+1} = x_t$ and $y_{t+1} = y_t$. 

A steady state occurs when there is no daily change, so $x_{t+1} - x_t = 0$ and $y_{t+1} - y_t = 0.$ We can figure out the steady state values are by substituting $x_{t+1} = x_t = x$ and $y_{t+1} = y_t = y$ into Eq.\@ref(eq:ross1b) and then solving for $x$ and $y$. After cancelling and rearranging, we get:

\begin{equation}
\begin{array}{rl}
m a y (1-x) &=  s x \\ 
a x (1 - y) &=  u y\\ 
\end{array}
(\#eq:ross1steady)
\end{equation}

Equations \@ref(eq:ross1steady) say: *the proportion of humans becoming infected is equal to the proportion clearing infections*; and *the proportion of mosquitoes becoming infected is equal to the proportion dying.*

The most obvious solution to these equations is $x=y=0,$ when there is no malaria. We call it the disease-free steady state. A disease-free equilibrium makes sense, since if we start with no infected mosquitoes or infected humans in this deterministic model, there can never be any. 

There is another solution where malaria is present. We solve the second equation first: 

$$y = a x / (u + a x).$$ 

Next, we substitute this for the $y$ term that is in the first equation, and we get: 

$$m a^2 (1-x) =  s (u+ax)$$ 

and now we solve for $x$

$$x = \frac{\textstyle{ma^2 - su}}{\textstyle{ma^2 + sa}}$$
We can write a function to compute this steady state: 

```{r ross_dts_steady_0, echo=TRUE}
# INPUTS
# params - the parameters, as a list 
#
# OUTPUTS
# the steady state values of x and y 
ross_dts_steady_0 = function(params){with(params,{
  xx = (m*a^2 - s*u)/ (m*a^2 + s*a)
  yy = a*xx/(u+a*xx) 
  c(x=xx,y=yy)
})}
```

```{r, echo=TRUE}
ross_dts_steady_0(ross_dts_par)
```

#### Thresholds 

All our analysis worked out well for the parameter values that we chose, but what if we had picked different parameters? 

There must be some very low level of mosquitoes, for example, where malaria parasites can't be sustained in a population. If we reduce $m$ to $0.005$ and evaluate the expression at the steady state, we get negative values for $x$ and $y$. 

```{r, echo=TRUE}
ross_dts_par1 = ross_dts_make_par(m=0.005) 
ross_dts_steady_0(ross_dts_par1)
```

What happens if we simulate this? (Let's set the initial conditions to reasonably high values) 

```{r ross_diffs_1_zero, echo=TRUE}
# Set initial conditions
xy = c(t=0, x=0.7, y=0.5)
xy_t = xy 
# Solve 
for(t in 1:1500){
  xy = ross_diffs_1(xy, ross_dts_par1) 
  xy_t = rbind(xy_t, xy)
} 
# Plot 
with(as.data.frame(xy_t), {
  plot(t, x, "n", ylim = range(0, 1), ylab = "Prevalence", xlab = "Time")
  lines(t, x, col = "darkgreen", pch =15)
  lines(t, y, col = "darkorange", pch =19)
  text(10, 0.9, "x", col = "darkgreen", pos=4) 
  text(10, 0.8, "y", col = "darkorange", pos=4) 
})
```

Our function `ross_dts_steady_0` gives us a negative number.

```{r, echo=TRUE}
ross_dts_steady_0(ross_dts_par1)
```

If we look at the equations, it's easy enough to spot the problem. Since $x$ and $y$ must be positive, then it must be true that $$m a^2 > su.$$ We call this a threshold condition.

```{r, echo=TRUE}
m_crit = with(ross_dts_par, s*u/a^2)
m_crit 
```

If we check, we find that this gives us the disease free equilibrium.  

```{r, echo=TRUE}
ross_dts_par2 = ross_dts_make_par(m=m_crit)
ross_dts_steady_0(ross_dts_par2)
```

It doesn't make sense to have a negative amount of malaria. Since `ross_dts_steady_0`gives us negative numbers, we can use this little bit of information to write a better function, one that returns $0$ instead of a negative number: 

```{r ross_dts_steady_1, echo=TRUE}
# INPUTS
# params - the parameters, as a list 
#
# OUTPUTS
# the steady state values of x and y 
ross_dts_steady_1 = function(params){with(params,{
  xx = ifelse(m*a^2 > s*u, (m*a^2 - s*u)/(m*a^2 + s*a), 0) 
  yy = a*xx/(u+a*xx) 
  c(x=xx,y=yy)
})}
```

```{r, echo=TRUE}
ross_dts_steady_1(ross_dts_par1)
```

In [The Ross-Macdonald Model], we'll take another look at thresholds. 

## Computation {#basicComputation}

A lot of analysis can be done with a pencil and paper, but this book is taking a computational approach. Here, we introduce some conventions that we will use to build software that can support robust analytics.  

### Functions 

Computers are very good at repeating tasks, but if we want to get the computers to repeat tasks efficiently, we must write code that does it. One useful trick is to write functions that call other functions to expedite workflows. In this case, we want to write a function that *solves* the equations (*i.e.* that iteratively computes and stores the values) over some time interval:  

```{r ross_dts_solve_1, echo=TRUE}
# INPUTS
# pars - the parameters, as a list 
# x0   - the initial value of x
# y0   - the initial value of y
# t0   - the initial value of t
# tmax - the last value of t 
#
# OUTPUTS
# the values of the variables over time, as a list 
ross_dts_solve_1 = function(pars, x0=.01, y0 = 0.001, t0=0, tmax=100){
   xy = c(t=t0, x=x0, y=y0)
   xy_t = xy 
   for(t in (t0+1):tmax){
     xy = ross_diffs_1(xy, pars)
     xy_t = rbind(xy_t, xy)
   }
   return(list(time=xy_t[,1], x=xy_t[,2], y = xy_t[,3], last = xy)) 
}
```

We can write another function that *plots* the equations (*i.e.* that iteratively computes and stores the values) over some time interval:  
 
```{r plot_xy, echo=TRUE}
# INPUTS
# xy_t - a list with elements named x, y, and time
# type - plot type:  "l" or "p" or "b"
# lty  - lty  
# add  - if TRUE, add to existing plot 
#
# OUTPUTS
# the values of the variables over time, as a list 
plot_xy = function(xy_t, type = "l", lty=1, add=FALSE){with(xy_t,{
  if(add == FALSE) 
  plot(time, x, "n", ylim = range(0, 1, y, x), ylab = "Prevalence", xlab = "Time")
  lines(time, x, type = type, lty=lty, col = "darkgreen", pch =15)
  lines(time, y, type = type, lty=lty, col = "darkorange", pch =19)
  text(0, 0.9, "x", col = "darkgreen", pos=4) 
  text(0, 0.8, "y", col = "darkorange", pos=4) 
})}
```


Now, we can define, solve and plot a model in a single line of code:

```{r replot_ross_diffs_1, echo=TRUE}
plot_xy(ross_dts_solve_1(ross_dts_make_par(), tmax=40), type="p") 
```

We're not necessarily advocating that we write code this way. It's not always easy to find and diagnose problems, or to repeat it. We shouldn't do everything just because we can. This code does the same thing in a form that's easier to follow: 

```{r rereplot_ross_diffs_1, echo=TRUE}
params <- ross_dts_make_par()
output <- ross_dts_solve_1(params, tmax=40) 
plot_xy(output, type="p") 
```

### Verification 

If we're going to take ourselves seriously, we want to get used to double checking everything to avoid making and propagating mistakes. One way to do this is to find two or more ways of computing the same thing, for verification.

If we've done everything right, we ought to get the same values for the steady states through our analysis and simulation. 

The last values of $x$ and $y$ from the simulation are: 

```{r, echo=TRUE}
output$last[-1]
``` 

The last values of $x$ and $y$ from evaluating `ross_dts_steady_1()` are:  

```{r, echo=TRUE}
ross_dts_steady_1(params) 
```

It's tempting to look at the printout and assume these two numbers are exactly equal, but when we deal with computers, everything gets computed and stored in some way. We can never be sure that a match will be be exact. We can simply sum up the absolute values of the differences: 

```{r, echo=TRUE}
sum(abs(output$last[-1] - ross_dts_steady_1(params)))
```

If we wanted to reduce this to a simple error check, we should pick a tolerance level -- say $10^{-9}$ -- and then just ask if we are closer than that: 

```{r, echo=TRUE}
# INPUTS
# xy  - xy 
# par - a set of parameters for a ross_dts model 
# tol - a tolerance level 
#
# OUTPUTS
# boolean - 
ross_dts_checkit_1 = function(params, tmax=200, tol=1e-9){
  xy1 <- ross_dts_solve_1(params, tmax=tmax)$last[-1]
  xy2 <- ross_dts_steady_1(params)
  sum(abs(xy1 - xy2)) < tol
}
```

There are decisions to make. How long should we run the model? If we don't run the simulation model for long enough, it will not have converged. 

```{r, echo=TRUE}
ross_dts_checkit_1(ross_dts_par, tmax=40)
```
In this case, the model converges for the default value of `tmax` that we set: 

```{r, echo=TRUE}
ross_dts_checkit_1(ross_dts_par)
```

## Events and Counting {#countingEvents}

There is a problem with `ross_diffs_1.` If we set $m$ too high, such that at some point $m a y_t > 1,$ then the whole system eventually crashes:

```{r ross_dts_mess, echo=TRUE}
ross_dts_par3 = ross_dts_make_par(m=12.5)
plot_xy(ross_dts_solve_1(ross_dts_par3, x0 = .01, y0=.001, tmax=39), "b") 
```

We need a good way of dealing with the problem that gave rise to this numerical instability. The question at hand is what fraction of people would become infected, on average, if the expected number of bites was $may_t?$ Ideally, we want to return a proportion, even when $may_t>1.$ We call this quantity -- the fraction that gets infected in a day -- the *daily attack rate.* 

How should we compute the probability of infections if we expect to get exposed more than once?  


### On not not getting infected

In discrete time formulations, we must be very careful to ensure that we have formulated a proper model. How can we fix this problem? We have to go back and rethink the way we formulated our model. How does the probability of getting infected scale with the number of infective bites?

If we knew that there were exactly an integer number of bites, $ma,$ then the proportion of people not getting infected would be those that didn't get infected from any one of the bites, or $(1-y_t)^{ma}.$ There is, however, an even better way to think about this.   

In a lot of cases like this, without any other information, we would assume that the number of bites, per person, would follow a Poisson distribution. It's actually easier to say who doesn't get infected, and that's the zero term of a Poisson, $e^{-may_t}.$ The probability of getting infected is the complement of the probability of getting at least one bite, or 

$$1 - e^{-m a y_t}$$ 

### `ross_dts_2` {#dtsRoss2}

**Equations** 

Our variables, initial conditions, and parameters are all defined in the same way as `ross_diffs_1,` but now our equations have changed:

\begin{equation}
\begin{array}{rl}
x_{t+1} &=  x_t - s x_t + (1-e^{-m a y_t}) (1-x_t)  \\ 
y_{t+1} &=  y_t - u y_t + a x_t (1 - y_t) \\ 
\end{array}
(\#eq:ross1c)
\end{equation}

As before, we write a function to numerically solve the discrete time system: 

```{r ross_dts_2, echo=TRUE}
# INPUTS
# xy      - current variables, as a named vector
# params  - the parameters, as a list
#
# OUTPUTS
# the updated values of the variables, as a named vector
ross_dts_2 = function(xy, params){with(as.list(xy), with(params,{
  xn = x - s*x + (1-exp(-m*a*y))*(1-x) 
  yn = y - u*y + a*x*(1-y) 
  t=t+1
  return(c(t=t, x=xn, y=yn))
}))}
```

Once again, we can wrap a function around the solver so that it's easier to use the code: 

```{r ross_dts_solve_2, echo=TRUE}
# INPUTS
# pars - the parameters, as a list 
# x0   - the initial value of x
# y0   - the initial value of y
# t0   - the initial value of t
# tmax - the last value of t 
#
# OUTPUTS
# the values of the variables over time, as a list 
ross_dts_solve_2 = function(pars, x0=.01, y0 = 0.001, t0=0, tmax=100){
   xy = c(t=t0, x=x0, y=y0) 
   xy = c(t=0, x=x0, y=y0) 
   xy_t = xy 
   for(t in (t0+1):tmax){
     xy = ross_dts_2(xy, pars)
     xy_t = rbind(xy_t, xy)
   }
   return(list(time=xy_t[,1], x=xy_t[,2], y = xy_t[,3], last = xy)) 
}
```

Now, we can visualize the output using code we've already written, and can see that we have fixed our stability problem. 

```{r plot_ross_dts_2, echo=TRUE}
plot_xy(ross_dts_solve_2(ross_dts_par3, x0 = .01, y0=.001, tmax=20), "b") 
```

**Verification** 

For verification, we want a method to solve things two different ways. If we want to compute the steady state, we're stuck with the problem of solving this equation:  

$$(1-e^{-m a^2 x/(u + a x)}) (1-x) = sx$$ 

It's surprisingly easy to write down equations, like this one, that we can't solve with pencil and paper. We can still find a way of computing the steady state, but we have to write R code that solves for $x$ numerically. 

```{r ross_dts_steady_2, echo=TRUE}
# INPUTS
# par - the model parameters, as a list 
#
# OUTPUTS
# the steady state values of x and y 
ross_dts_steady_2 = function(pars, tol=1e-10){with(pars,{
   f_xx = function(x, pp){with(pp,{
     xx = (1 - exp(-m*a^2*x/(u+a*x)))*(1-x) - s*x
     y = a*xx/(u+a*xx)
     yy = u*y + a*xx*(1-y) 
     return(xx^2 + yy^2)
   })}
   xx = optimize(f_xx, c(0,1), pp=pars, tol = tol)$min
   yy = a*xx/(u+a*xx) 
   c(xx, yy)
})}
```

Finding the equilibrium this way, we get: 

```{r, echo=TRUE}
ross_dts_steady_2(ross_dts_par3)
```

Second, by getting the solution after many iterations. 

```{r, echo=TRUE}
ross_dts_solve_2(ross_dts_par3, x0=.1, y0=.05, tmax=300)$last[-1]
```

By inspection, these two numbers are very close, but not exactly matching. Once again, we want to ensure that our code does not have any mistakes, so we write a function to verify our results. We set a term that describes an acceptable tolerance for computational errors, and ask if we're at least that close. 

```{r ross_dts_checkit_2, echo=TRUE}
# INPUTS
# xy     - xy 
# par    - a set of parameters for a ross_dts model 
# tmax   - maximum runtime for ross_dts_solve_2 
# st_tol - tolerance for ross_dts_steady_2
# tol    - desired tolerance for verification
#
# OUTPUTS
# boolean - 
ross_dts_checkit_2 = function(params, tmax=300, st_tol=1e-10, tol=1e-7){
  xy1 <- ross_dts_solve_2(params, tmax=tmax)$last[-1]
  xy2 <- ross_dts_steady_2(params, tol=st_tol)
  sum(abs(xy1 - xy2)) < tol
}
```

Do the two answers differ by less than $10^{-7}$? 

```{r, echo=TRUE}
ross_dts_checkit_2(ross_dts_par3)
```

It's a little unsatisfying to get numerical errors, but machines don't do exact computation easily. We're interested in getting as close as we need to get without doing a lot of work that would, in the end, never make a difference. The operating principle here is that we need to be sure that our code is doing what we think it should, and that it is giving answers that are close enough.

## Stochastic, Discrete Time {#sdtsRoss}

*Demographic stochasticity.* 

***

If we followed individuals in a population that followed the simple rules described in Equation \@ref(eq:Mprocess) and Equation \@ref(eq:Hprocess), we would like to be able to understand how they are connected to the deterministic equations we developed in  Section-\@ref(dtsRoss). Setting aside the problems that get introduced by sampling populations for the moment -- we will pretend we're omniscient -- we would find random changes occurring:

+ individual humans would be switching states over time at random: from infected to uninfected and back; 

+ individual mosquitoes would be dying at random: infected mosquitoes would get replaced by uninfected mosquitoes, and uninfected mosquitoes would be blood feeding and getting infected if they blood fed on an infected (and infectious) human. 

The world really has a random component to it. It is not deterministic but stochastic. 

In the *deterministic* models that we called `ross_diffs_1` and `ross_dts_2,` the values of each variable at each point in time were specified *exactly* by the equations, the rules for updating the variables each day. The values of the variables were *proportions,* which is related to the metric *prevalence.* In these models, the variables asymptotically approach a *steady state.* Once at the steady state, the fractions infected would never change.  

In models with stochasticity, we could use the same exact rules to specify what is expected to happen, but we must draw a random number to determine the values of the variables. To do this, we want to be working with the counting numbers -- the number of humans in a population and the number of those humans who are infected; and the number of mosquitoes in a population, and the number of those mosquitoes who are infected. The variability in the values of our variables over time due to the random component of parasite infection dynamics -- also called the parasite demographics -- would be called **demographic stochasticity.**  The model has *some* things in common with the ones we described above: the model doesn't have a steady state, but there is something like a steady state that the variables fluctuate around. We'll call it an attractor. The variables are always pulled towards the attractor, but the values of the variables are constantly changing around it.  

In a real study, we can't pretend to be omniscient, but we will discuss that later. 

**Parameters** -- We can use the same parameters as before, but there are two new parameters:

+ $M$ is the number of mosquitoes: $M$ is a counting number 

+ $H$ is the number of humans; $H$ is a counting number

Otherwise we use the same parameters as we did before. 

```{r, echo=TRUE}
# The parameters, as a list 
ross_sdts_par = list(
  M = 50,   # The number of mosquitoes 
  H = 100,   # The number of humans 
  s = 1/200, # The fraction of infections that clear each day
  u = 1/12,  # The fraction of mosquitoes that die each day
  a = 1/4   # The fraction of mosquitoes that blood feed on a human each day
)
ross_sdts_par$m = with(ross_sdts_par, M/H)
```

**Variables** 

In the stochastic model, our variables are counting numbers, not fractions: 

+ $Y \leq M$ is the number of infected mosquitoes: $Y$ is a counting number

+ $X \leq H$ is the number of infected humans: $X$ is a counting number 

It is easy enough to define prevalence: 

+ $x = X/H$ is malaria prevalence in humans; the fraction of humans infected 

+ $y = Y/M$ is malaria prevalence in mosquitoes; the fraction of mosquitoes infected 

**Equations** 

Now we have got to describe a stochastic process. Each individual changes state with some probability. Each one is a Bernoulli random variable, and the appropriate proability mass function is the binomial model. In R, we use the built-in function `rbinom(1, N, p)` to draw one random variable on $N$ individuals that remains in the same state with probability $p$. 

In each step, there are four possible changes, depending on the states: 

+ $X$ - if humans are infected today, they might lose infection. An infection is lost with probability $s$, so the fraction that remain infected is $1-s.$ The number that remains infected is `rbinom(1, X, 1-s).` 

+ $H-X$ - if humans are uninfected today, they might get infected. The probability of getting infected is called the *daily attack rate.*  The expected number of infected bites is $aY/H$, and if we use the Poisson to model the distribution of bites per person, then the attack rate is $1-e^{-aY/H}$. The number that remains ends up infected is `rbinom(1, H-X, ar).` 

+ $Y$ - if mosquitoes are infected today, they might die. The fraction dying is $u$, so the number of surviving infected mosquitoes is `rbinom(1, X, 1-s).` 

+ $H-Y$ - if mosquitoes are uninfected today, they might get infected. To get infected, a mosquito must blood feed on an infected human, so the fraction getting infected is $aX/H$. The number that gets infected is `rbinom(1, H-Y, a X/H).` 

The rule for updating the number of infected humans and mosquitoes is thus:

\begin{equation}
\begin{array}{rl}
X_{t+1} &= \mbox{Binom}(X, 1-s) + \mbox{Binom}(H-X, 1-e^{-a Y/H}) \\
Y_{t+1} &= \mbox{Binom}(Y, 1-u) + \mbox{Binom}(M-Y, aX/H) \\
\end{array}
\end{equation}

The following implements this as R code: 

```{r ross_sdts, echo=TRUE}
# XY      - a vector of the form c(t, X, Y) 
# params  - the parameters, as a list 
ross_sdts = function(XY, params){
  with(as.list(XY), 
    with(params,{
      ar = 1 - exp(-a*Y/H)
      Xn = rbinom(1, X, 1-s) + rbinom(1, H-X, ar)  
      Yn = rbinom(1, Y, 1-u) + rbinom(1, M-Y, a*X/H)  
      t=t+1
      return(c(t=t, X=Xn, Y=Yn))
}))}
```

We write a wrapper that solves it: 

```{r sim_ross_sdts, echo=TRUE}
# INPUTS
# pars - the parameters, as a list 
# X0   - the initial number of infected humans
# Y0   - the initial number of infected mosquitoes 
# t0   - the initial value of t
# tmax - the last value of t 
#
# OUTPUTS
# the values of the variables over time, as a list 
sim_ross_sdts = function(pars, X0=2, Y0 = 1, t0=0, tmax=100){
   XY = c(t=t0, X=X0, Y=Y0) 
   XY_t = XY 
   for(t in (t0+1):tmax){
     XY = ross_sdts(XY, pars)
     XY_t = rbind(XY_t, XY)
   }
   X=XY_t[,2] 
   Y=XY_t[,3]
   x=X/pars$H 
   y=Y/pars$M 
   return(list(time=XY_t[,1], x=x, y=y, X=X, Y=Y, last = XY)) 
}
```

We can write another function that *plots* the equations (*i.e.* that iteratively computes and stores the values) over some time interval:  
 
```{r plot_XY, echo=TRUE}
# INPUTS
# XY_t - a list with elements named x, y, and time
# type - plot type:  "l" or "p" or "b"
# lty  - lty  
# add  - if TRUE, add to existing plot 
plot_XY = function(XY_t, type="l", lty=1, add= FALSE){with(XY_t,{
  if(add == FALSE) 
  plot(time, X, type = "n", ylim = range(0, X, Y), ylab = "Number Infected", xlab = "Time")
  lines(time, X, type=type, lty=lty, col="darkgreen", pch =15)
  lines(time, Y, type=type, lty=lty, col="darkorange", pch =19)
  text(0, 0.9*max(X,Y), "X", col = "darkgreen", pos=4) 
  text(0, 0.8*max(X,Y), "Y", col = "darkorange", pos=4) 
})}
```

A useful feature of R is the ability to replicate any particular sequence of random numbers by setting a *seed.* This also makes it easy to write a book knowing what the random number sequence will be. 

```{r, echo=TRUE}
set.seed(253)
XYt <- sim_ross_sdts(ross_sdts_par, tmax=1000) 
```


```{r, fig.height=4, fig.width=7, echo=TRUE}
plot_XY(XYt)
```

Once we're close to the steady state, some time after the first 100 days, we can compute the mean: 

```{r XYdist}
Xdist= with(XYt, X[-c(1:100)]) 
Ydist= with(XYt, Y[-c(1:100)]) 
mX = mean(Xdist)
mY = mean(Ydist) 
c(X=mX, Y=mY)
```

This can be visualized as a histogram: 

```{r, fig.height=4, fig.width=8}
par(mfrow=c(1,2))
hist(Xdist,  xlab = "x", main = "X, for t>100")
segments(mX, 0, mX, 250, lwd=4, col = "darkgreen")
hist(Ydist, 15, xlab = "y", main = "Y, for t>100")
segments(mY, 0, mY, 200, lwd=4, col = "darkorange")
```

Since we can compute prevalence, we can plot it out: 

```{r, fig.height=4, fig.width=7, echo=TRUE}
plot_xy(XYt)
```


```{r, echo=TRUE}
xdist= with(XYt, x[-c(1:100)]) 
ydist= with(XYt, y[-c(1:100)]) 
mx = mean(xdist)
my = mean(ydist)
c(x=mx, y=my) 
```

```{r, fig.height=4, fig.width=8}
par(mfrow=c(1,2))
hist(xdist,  xlab = "x", main = "x, for t>100")
segments(mx, 0, mx, 250, lwd=4, col = "darkgreen")
hist(ydist, 15, xlab = "y", main = "y, for t>100")
segments(my, 0, my, 200, lwd=4, col = "darkorange")
```

The system still tends towards a point -- we'll call it an attractor and not a steady state. The values of $X$ and $Y$  (or of $x$ and $y$) fluctuate around that steady state. Since the counting number values get repeated, we can illustrate what the cloud looks like by jittering the locations of the points:

```{r, fig.height=5, fig.width=4, echo=TRUE}
with(XYt,{
  ix = which(time>100)
  plot(jitter(X[ix],1.5), jitter(Y[ix],1.5), xlab = "X", ylab = "Y", cex=0.2)
}) 
points(mX, mY, col = "darkred", pch = 8, cex =3)
```

We note that mean prevalence is very close to the steady state of the deterministic system with the same parameter values:

```{r, echo=TRUE}
c(mx, my) - ross_dts_steady_1(ross_sdts_par)
```

An important feature of stochastic systems is that it is possible for the parasite to randomly fade out, if at any time $X=Y=0.$ This is something we'd like to take a bit more time computing.


## Deterministic, Continuous Time {#xdeRoss}

*Differential equations.* 

*** 

In this section, we present a basic, deterministic, continuous-time model. After seeing the `ross_dts` models, this model will look and feel familiar. Instead of describing a difference over a fixed time step, we describe a derivative. The idea of  derivative is usually introduced as the second new concept in any introduction to calculus. Instead of describing the fraction of a population that changes over any fixed time interval, the derivative describes change over an interval of time that is infinitesimally small. 

To understand differential equations, you will need a background in calculus. If you've had a semester of calculus, you will have come across derivatives. Depending on how much calculus, you might not have solved differential equations. The point of this book is to introduce malaria analytics, so we will not be delving into mathematical theory or numerical methods very much.

In discrete-time, the equations could be written in this form:  

$$
\begin{array}{rl}
x_{t+1} - x_t &=  F_x (x_t, y_t) \\ 
y_{t+1} - y_t &=  F_y (x_t, y_t)  \\ 
\end{array}
$$
The left hand side says "the difference in" $x$ or $y$ "over one time step is equal to" $F_x$ or $F_y,$ which are functions of the two variables. We can now ask what would happen if we sub-divided a day into $n$ equal periods. In the limit as $n$ goes to infinity, we replace the differences (terms on the left hand side) with derivatives. The differential equations are now written in this form:

$$
\begin{array}{rl}
\frac{\textstyle{dx}}{\textstyle{dt}} &=  F_x (x, y)  \\ 
\frac{\textstyle{dy}}{\textstyle{dt}} &=  F_y (x, y) \\ 
\end{array}
$$

These differential equation models have the same components as the difference equations: variables, initial conditions, and parameters.

To compute anything, we will need to use numerical methods. Fortunately, R has a package to handle numerical methods for differential equations, called **deSolve.** 

```{r, echo=TRUE}
library(deSolve)
```

Here, we present and solve `ross_xde`a continuous time, deterministic model that is similar to Ross's 2nd model [@RossR1911Nature].

### `ross_xde`


**Variables** -- In `ross_xde,` the dependent variables have the same meaning as in the `ross_dts` equations, but the independent variable. We now write an equation describing the fraction of humans and mosquitoes that are infected at each point in time. 

+ Let $x(t)$ be the fraction of people who are infected at time $t,$ and $0 \leq x(t) \leq 1.$

+ Let $y(t)$ be the fraction of mosquitoes who are infected at time $t,$ $0 \leq y(t) \leq 1.$ 

**Initial Conditions** -- As before, we will need to define initial conditions. 

```{r, echo=TRUE}
ross_xde_inits = c(x=0.01, y=0.01)
```

**Parameters** -- In this model, the parameters describe rates of change. 

  + Let $r$ denote the fraction of people who clear infections after one day; $0 < r < 1.$ 

  + Let $g$ denote the fraction of mosquitoes who die in one day; $0 < g < 1.$ 

  + Let $a$ denote the fraction of mosquitoes who blood feed on a human in a day; $0 < a < 1.$ 

  + Let $m$ denote the number of mosquitoes per human; $m \geq 0.$ 

```{r, echo=TRUE}
# The parameters, as list 
ross_xde_par = list(
  r = 1/200, # The clearance rate for infections 
  g = 1/12,  # The mosquito daily death rate 
  a = 1/4,   # The mosquito human blood feeding rate 
  m = 0.5      # The number of mosquitoes per human
) 
```


**Equations** -- Finally, we put all this together into a mathematical statement that has translated the description of a process. There are four terms: 

+ The fraction of humans who are infected is $x$; infections clear at the rate $r.$ 
    
+ The fraction of mosquitoes who are infected is $y$; mosquitoes die at the rate $g.$ 
    
+ The fraction of humans who are not infected is $1-x$; infections occur at the rate $m a y.$ 
    
+ The fraction of mosquitoes who are not infected is $1-y$; infections occur at the rate $a x.$ 

$$ 
\begin{array}{rl}
dx/dt &= may(1-x) - r x\\
dy/dt &= ax(1-y) - g y \\
\end{array}
$$ 

The form of the function that computes the derivatives in R is defined by `deSolve
`
```{r ross_xde, echo=TRUE}
# INPUTS
# t - the current time 
# vars - the variables, as a named vector 
# pars - the parameters, as a list
# OUTPUTS
# the derivatives, as a list 
ross_xde = function(t, vars, pars){
  with(pars, 
    with(as.list(vars),{
    
      dxdt = m*a*y*(1-x) - r*x
      dydt = a*x*(1-y) - g*y
  
      return(list(c(dxdt, dydt)))
    })
  )
}
```

### Rates *vs.* Proportions 

The rates in differential equations can be compared to the proportions in discrete time systems. When the rates describe a change of state, a loss term for one of the variables, there are two easy interpretations. First, we consider the rate of loss of infected humans in a population, $-rx.$ The core underlying process is exponential decay. If we followed a cohort, the waiting time for an individual to change states would follow an exponential distribution with rate $1/r$. Second, after one day, the fraction that remains infected is $e^{-r}$. If we set $r=1/200,$ for example, the expected waiting time to clear an infection is 200 days. The rate of loss after one day is very close to, but slightly less than $r$:

```{r, echo=TRUE}
c(1/200, 1-exp(-1/200)) 
```


### Solutions 

We now want to solve the initial value problem: given $x(0)$ and $y(0),$ can we find solutions $x(t)$ and $y(t)$? To do so, we call `deSolve::ode,` which takes for arguments: the initial values, the points in time to ouput values of $x(t)$ and $y(t)$, a function that computes the derivatives, and the parameters: 

```{r, echo=TRUE}
deSolve::ode(ross_xde_inits, 0:5, ross_xde, ross_xde_par)
```


### Computation & Visualization

For easy in working with these equations, we write a wrapper:  

```{r, echo=TRUE}
# INPUTS: 
# pars -- the parameter values, as a list
# x0   -- the initial value for x(t) 
# y0   -- the initial value for y(t) 
# tmax -- the largest value of t  
# dt   -- the interval for t 
# OUTPUT: 
# the output of ode as a data.frame 
ross_xde_solve = function(pars, x0=.01, y0=0.001, tmax=100, dt=1){
  tms = seq(0, tmax, by = dt)
  xy0 = c(x=x0, y=y0)
  data.frame(ode(xy0, tms, ross_xde, pars)) 
}
```


```{r, echo=TRUE}
ode_out <- ross_xde_solve(ross_xde_par)
```

Because we have returned it as a data frame, the column names are `time` and `x` and `y.` We can plot the values using `with().`

```{r, echo=TRUE}
plot_xy(ode_out)
```


These differential equations require  

### Steady States 

We can learn a bit more about how these equations behave by changing the initial values: 

```{r, echo=TRUE}
ode_out1 <- ross_xde_solve(ross_xde_par, x0=0.2, y0=0.02)
ode_out2 <- ross_xde_solve(ross_xde_par, x0=.99, y0=0.99)
```

```{r, echo=TRUE}
plot_xy(ode_out)
plot_xy(ode_out1, lty=2, add=TRUE)
plot_xy(ode_out2, lty=3, add=TRUE)
```

We notice that the orbits all asymptotically approach the same values, regardless of where they started. Once there, they stay there. 

### Verification  

We ought to be able to compute the value of these steady states: it is a value of $x(t)$ and $y(t)$ such that $dx/dt=dy/dt=0.$ To find it, we set $dx/dt=dy/dt=0$ and solve for $x$ and $y.$ One obvious value, once again, is $x=y=0.$

$$ 
\begin{array}{rl}
0 &= may(1-x) - r x\\
0 &= ax(1-y) - g y \\
\end{array}
$$ 

Solve the second equation for $y$ 

$$y = ax/(g+ax)$$

Substitute back into the first equation: 

$$ma^2 (1-x) = r(g+ax)$$ 
and solve. 

$$x = \frac{\textstyle{m a^2 - rg}}{\textstyle{m a^2 + ra}}$$ 

Noting that $m a^2 > rg$ must be a threshold condition, we write a function to compute the steady state using the formula we just derived: 

```{r ross_xde_steady}
ross_xde_steady_1 = function(pars){with(pars,{
  xx = ifelse(m*a^2 > r*g, (m*a^2 - r*g)/(m*a^2 + r*a), 0) 
  yy = a*xx/(g+a*xx)
  c(x=xx, y=yy)
})}
```

```{r, echo=TRUE}
ross_xde_steady_1(ross_xde_par)
```

We check it against the other way, which involves running the system for a very long time.

```{r, echo=TRUE}
de_eq <- ross_xde_solve(ross_xde_par, tmax=500, dt=5)
with(de_eq, c(x=tail(x,1), y=tail(y,1))) 
```

### Thresholds 

write me. 

## Stochastic, Continuous Time {#sxdeRoss}

In continuous time, the state of the system is updated one event at a time.

+ The total rate of change of the system is $T = may(H-X) + rX + aX(M-Y) + gY$

+ $Y \rightarrow Y+1$  

+ $Y \rightarrow Y-1$  

+ $X \rightarrow X+1$  

+ $X \rightarrow X-1$  

```{r, echo=TRUE}
# The parameters, as list 
ross_sxde_par = list(
  r = 1/200, # The clearance rate for infections 
  g = 1/12,  # The mosquito daily death rate 
  a = 1/4,   # The mosquito human blood feeding rate 
  M = 50,   # The number of mosquitoes 
  H = 100    # The number of humans
) 
```

```{r, echo=TRUE}
ross_sxde = function(XY, pars){
  with(as.list(XY), with(pars,{
    p1 = a*Y*(H-X)/H
    p2 = r*X 
    p3 = a*X*(M-Y)/H
    p4 = g*Y 

    t = t + rexp(1, p1+p2+p3+p4)
    
    event = sample(1:4, 1, prob=c(p1, p2, p3, p4))
    if (event==1) X <- X+1
    if (event==2) X <- X-1
    if (event==3) Y <- Y+1
    if (event==4) Y <- Y-1
    
    return(c(t=t,  X=X, Y=Y, x=X/H, y=Y/M))
}))}
```

```{r, echo=TRUE}
xy = c(t=0, X=10, Y=10)
for (i in 1:5){
  xy <- ross_sxde(xy, ross_sxde_par)
  print(xy)
}
```

```{r, echo=TRUE}
sim_ross_sxde = function(pars, X0=2, Y0=1, tmax=300){
   XY = c(t=0, X=X0, Y=Y0) 
   tm = XY[1]
   XY_t = c()  
   while(tm < tmax){
     XY = ross_sxde(XY, pars)
     tm = XY[1]
     XY_t = rbind(XY_t, XY)
   }
   return(list(time=XY_t[,1], X=XY_t[,2], Y=XY_t[,3], x = XY_t[,4], y = XY_t[,5])) 
}
```

```{r, echo=TRUE}
out <- sim_ross_sxde(ross_sxde_par)
```

```{r, fig.height=8, fig.width=7}
par(mfrow = c(2,1))
plot_XY(out)
plot_xy(out)
```


```{r, fig.height=4, fig.width=8}
par(mfrow=c(1,2))
with(out,{
  ix = which(time>100)
  xdist= X[ix]; mx = mean(xdist)
  ydist= Y[ix]; my = mean(ydist) 
  hist(xdist, 10, xlab = "X", main = "X, for t>100")
  segments(mx, 0, mx, 250, lwd=4, col = "darkgreen")
  hist(ydist, 15, xlab = "Y", main = "Y, for t>100")
  segments(my, 0, my, 200, lwd=4, col = "darkorange")
})
```

If we want to compare it to the other model, we can compute prevalence:  

```{r, fig.height=4, fig.width=8}
par(mfrow=c(1,2))
with(out,{
  ix = which(time>100)
  xdist= x[ix]; mx = mean(xdist)
  ydist= y[ix]; my = mean(ydist) 
  hist(xdist, 10, xlab = "x", main = "x, for t>100")
  segments(mx, 0, mx, 250, lwd=4, col = "darkgreen")
  hist(ydist, 15, xlab = "y", main = "y, for t>100")
  segments(my, 0, my, 200, lwd=4, col = "darkorange")
})
```

## Mathematical Species {#mathSpecies}

What species of mathematics is best suited for a task? Does it matter what species of mathematics we choose to build our models?  

As we use models to help us understand malaria in some particular place, we are faced with some questions about to interpret the outputs of models. One of the reasons we presented deterministic and stochastic models in discrete-time and in continuous-time was to learn about about modeling by drawing attention to some of the differences -- the models all represent the same process, but the outputs differ. Some of these differences are unsurprising and probably not important, but if we are to learn how to critically evaluate a model, we must pay attention to these differences.
s
```{r, echo=F}
# The parameters, as list 
ross_xde_par_5 = list(
  r = 1/200, # The clearance rate for infections 
  g = 1/12,  # The mosquito daily death rate 
  a = 1/4,   # The mosquito human blood feeding rate 
  m = 0.5,   # The number of mosquitoes per human
  H = 100,
  M = 50
) 
```

```{r, echo=F}
ross_xde_solve(ross_xde_par_5, x0=0.01, y=0.02, tmax=200, dt=1) -> r_xde
sim_ross_sxde(ross_xde_par_5, X0=1, Y0=1, tmax=200) -> s_xde0
sim_ross_sxde(ross_xde_par_5, X0=1, Y0=1, tmax=200) -> s_xde1
sim_ross_sxde(ross_xde_par_5, X0=1, Y0=1, tmax=200) -> s_xde2
sim_ross_sxde(ross_xde_par_5, X0=1, Y0=1, tmax=200) -> s_xde3
sim_ross_sxde(ross_xde_par_5, X0=1, Y0=1, tmax=200) -> s_xde4
sim_ross_sxde(ross_xde_par_5, X0=1, Y0=1, tmax=200) -> s_xde5
```

```{r, echo=F}
# The parameters, as a list 
ross_dts_par_5 = list(
#  s = 1-exp(-1/200), # The fraction of infections that clear each day
  s = 1/200, # The fraction of infections that clear each day
#  u = 1-exp(-1/12),  # The fraction of mosquitoes that die each day
  u = 1/12,  # The fraction of mosquitoes that die each day
  a = 1/4,   # The fraction of mosquitoes that blood feed on a human each day
  m = 0.5,   # The number of mosquitoes per human
  H = 100,
  M = 50
) 
```

```{r plot_x, echo=FALSE}
# INPUTS
# xy_t - a list with elements named x, y, and time
# type - plot type:  "l" or "p" or "b"
# lty  - lty  
# add  - if TRUE, add to existing plot 
#
# OUTPUTS
# the values of the variables over time, as a list 
plot_x = function(xy_t, type = "l", lty=1, clr="darkgreen", add=FALSE){with(xy_t,{
  if(add == FALSE) 
  plot(time, x, "n", ylim = c(0,1), main = "Human Infection Prevalence",
       ylab = "x - Proportion Infected", xlab = "Time")
  lines(time, x, type = type, lty=lty, col = clr, pch =15)
})}
``` 

```{r plot_y, echo=FALSE}
# INPUTS
# xy_t - a list with elements named x, y, and time
# type - plot type:  "l" or "p" or "b"
# lty  - lty  
# add  - if TRUE, add to existing plot 
#
# OUTPUTS
# the values of the variables over time, as a list 
plot_y = function(xy_t, type = "l", lty=1, clr="darkorange", add=FALSE){with(xy_t,{
  if(add == FALSE) 
  plot(time, y, "n", ylim = c(0,1), main = "Mosquito Infection Prevalence",
       ylab = "y - Proportion Infected", xlab = "Time")
  lines(time, y, type = type, lty=lty, col = clr, pch =15)
})}
```

```{r, echo=F}
ross_dts_solve_2(ross_dts_par_5, x0=0.01, y0=0.02, tmax=200) -> r_dts
ross_dts_solve_1(ross_dts_par_5, x0=0.01, y0=0.02, tmax=200) -> r1_dts
sim_ross_sdts(ross_dts_par_5, X0=1, Y0=1, tmax=200) -> s_dts0
sim_ross_sdts(ross_dts_par_5, X0=1, Y0=1, tmax=200) -> s_dts1
sim_ross_sdts(ross_dts_par_5, X0=1, Y0=1, tmax=200) -> s_dts2
sim_ross_sdts(ross_dts_par_5, X0=1, Y0=1, tmax=200) -> s_dts3
sim_ross_sdts(ross_dts_par_5, X0=1, Y0=1, tmax=200) -> s_dts4
sim_ross_sdts(ross_dts_par_5, X0=1, Y0=1, tmax=200) -> s_dts5
```


```{r, fig.height=8, fig.width=7, echo=F}
library(viridisLite)
clrs = turbo(4)
par(mfrow = c(2,1))
plot_x(r_xde,  clr = clrs[1])
plot_x(r_dts,  clr = clrs[2], add=T)
plot_x(s_dts0, clr = clrs[3], lty=2, add=T)
plot_x(s_xde0, clr = clrs[4], lty=2, add=T)

plot_y(r_xde,  clr = clrs[1])
plot_y(r_dts,  clr = clrs[2], add=T)
plot_y(s_dts0, clr = clrs[3], lty=2, add=T)
plot_y(s_xde0, clr = clrs[4], lty=2, add=T)
```

### Deterministic Models 

In the deterministic models, the variables over time are repeated in exactly the same way. If we changed a parameter or an initial condition, we would of course get different orbits. The discrete-time and continuous-time models differ slightly from each other. Some small differences will persist because we are dealing with non-linear processes. 

In the following, we have plotted the outputs of all three deterministic models, and the differences between the continuous time and the two discrete-time models (bottom). The main difference between the two models is that malaria prevalence increases more slowly in the discrete-time models. The model `ross_diffs_1` is slightly closer to the continuous time model. 

```{r compare, fig.height=8, fig.width=7, echo=F}
clrs = turbo(4)
par(mfrow = c(3,1))
plot_x(r_xde, clr = clrs[1])
plot_x(r_dts, clr = clrs[2], add=T)
plot_x(r1_dts, clr = clrs[4], add=T)

plot_y(r_xde, clr = clrs[1])
plot_y(r_dts, clr = clrs[2], add=T)
plot_y(r1_dts, clr = clrs[4], add=T)

tm = with(r_xde, time) 
dx = with(r_xde, x) - with(r_dts, x)
dy = with(r_xde, y) - with(r_dts, y)

dx1 = with(r_xde, x) - with(r1_dts, x)
dy1 = with(r_xde, y) - with(r1_dts, y)

plot(tm,  dx, type = "n", ylim = range(dx, dx1, dy, dy1),  ylab = "dx, dy", xlab = "Time", main = "Model Differences")
lines(tm, 0*dx, col = grey(0.8))
lines(tm,  dx, col = "darkgreen", lwd=2)
lines(tm,  dx1, col = "darkgreen", lwd=2, lty=3)
lines(tm,  dy, col = "darkorange", lwd=2)
lines(tm,  dy1, col = "darkorange", lwd=2, lty=3)
```



How different are these two models? We could develop a formal distance metric to compare two models. First, since the variables in the continuous-time model is defined for every value of $t$, but the discrete-time model is defined only for integer values of $t$, we can only make comparisons for integer values of $t.$ In the simulations above, we took care to output the values of both models at the same time points, so we can simply take the sum of squared differences:

```{r, echo=TRUE}
ssd_2mods = function(m1, m2, norm=1){
  dx = sum((with(m1, x) - with(m2, x))^2) 
  dy = sum((with(m1, y) - with(m2, y))^2) 
  return((dx+dy)/norm) 
}
```

```{r, echo=TRUE}
ssd_2mods(r_xde, r_dts, norm = length(r_xde$time))
```

Or the sub of their absolute values of the differences: 

```{r, echo=TRUE}
sabs_2mods = function(m1, m2, norm=1){
  dx = sum(abs(with(m1, x) - with(m2, x))) 
  dy = sum(abs(with(m1, y) - with(m2, y)))
  return((dx+dy)/norm) 
}
```

We can interpret this to mean that the average sum of differences is about 1.6\%

```{r, echo=TRUE}
sabs_2mods(r_xde, r1_dts, norm = length(r_xde$time))
```

### Stochastic Models 

In stochastic models, the values of the variables differ each time we run the model.  

```{r, fig.height=8, fig.width=7, echo=F}
library(viridisLite)
clrsA = mako(8)[2:7]
clrsB = rocket(8)[2:7]
par(mfrow = c(2,1))

plot_x(r_xde, clr=clrs[1])
plot_x(s_dts0, clr=clrsA[1], add=T)
plot_x(s_xde0, clr=clrsB[1], add=T)
plot_x(s_dts1, clr=clrsA[2], add=T)
plot_x(s_xde1, clr=clrsB[2], add=T)
plot_x(s_dts2, clr=clrsA[3], add=T)
plot_x(s_xde2, clr=clrsB[3], add=T)
plot_x(s_dts3, clr=clrsA[4], add=T)
plot_x(s_xde3, clr=clrsB[4], add=T)
plot_x(s_dts4, clr=clrsA[5], add=T)
plot_x(s_xde4, clr=clrsB[5], add=T)
plot_x(s_dts5, clr=clrsA[6], add=T)
plot_x(s_xde5, clr=clrsB[6], add=T)

plot_y(r_xde, clr=clrs[1])
plot_y(s_dts0, clr=clrsA[1], add=T)
plot_y(s_xde0, clr=clrsB[1], add=T)
plot_y(s_dts1, clr=clrsA[2], add=T)
plot_y(s_xde1, clr=clrsB[2], add=T)
plot_y(s_dts2, clr=clrsA[3], add=T)
plot_y(s_xde2, clr=clrsB[3], add=T)
plot_y(s_dts3, clr=clrsA[4], add=T)
plot_y(s_xde3, clr=clrsB[4], add=T)
plot_y(s_dts4, clr=clrsA[5], add=T)
plot_y(s_xde4, clr=clrsB[5], add=T)
plot_y(s_dts5, clr=clrsA[6], add=T)
plot_y(s_xde5, clr=clrsB[6], add=T)
```



## Notes

The discrete time models ross_diffs_1 and ross_dts_2 have been implemented in a [Google Sheet](https://docs.google.com/spreadsheets/d/1gM6VoHJSQcEUi96rOjLaGKLO5tnuAgENIz50Q6TAjZY/edit?gid=0#gid=0)

+ The Reed-Frost model

+ The chain-binomial model




