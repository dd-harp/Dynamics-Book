---
output:
  pdf_document: default
  html_document: default
---
# Basic Malaria Models 

Ross was interested in making plans about malaria control.
Given his interests in measuring malaria, he immediately noticed the importance of the fact that malaria prevalence differed from place to place.
Ross wanted to understand why, so he developed mathematical models of malaria as a way of understanding the prevalence of malaria infection among humans in a population.

Malaria infections in the two populations are connected through blood feeding, so malaria transmission works as an integrated system.
The process looks something like the following diagram.

![](Figures/LifeCycleModel.png)

How does malaria persist in a population? It persists through the transmission of parasites among hosts during blood feeding. What factors determine prevalence? It is a balance between the gain and loss of infection. To develop a mathematical model, Ross believed that it was possible to write down *a priori* -- or in other words, to formulate mathematical models using quantitative logic -- a description of the process. 

To write down a model, we must make some assumptions about the process.
We begin with an abstract concept of place: *here.* 
We imagine populations here comprised of individual mosquitoes and individual humans, and we are interested in computing the fraction of humans and mosquitoes that is infected. 
Since infections don't last forever, the prevalence of infection in mosquitoes and mosquitoes reflects a balance between infections acquired through parasite transmission and the natural loss of infection and host mortality.
In many places, this balance is always shifting as mosquito populations fluctuate.
He assumed that transmission by mosquitoes was constant over time, and he focused on *local* transmission, ignoring exposure elsewhere (*e.g.* through travel). 
This model thus ignores many factors that would be important for planning for control; Ross was pioneering a new approach so the models were rudimentary.

Mosquitoes lived short lives, so the loss of parasites in mosquitoes was mainly caused by mosquito mortality: 

$$
\mbox{MOSQUITOES} 
\\ \; \\
\left[
\begin{array}{rcl}
\mbox{Infected Tomorrow} &=& \mbox{Infected Today} \\
&-&\mbox{Infected: Died}\\
&+&\mbox{Uninfected: Got Infected}\\
\end{array} \right]
$$

This description of a process ignores the loss of infection in mosquitoes, and changes in mosquito populations through migration. The model did not explicitly say anything about a change in the number of uninfected mosquitoes through *emergence* from aquatic habitats. It ignored the lag between the point in time when a mosquito gets infected and when it becomes infectious. The basic mathematical model we will describe in the next section effectively assumes that the mosquito population does not change, so every mosquito that dies is replaced with an uninfected mosquito.  

Humans live long lives, so parasite loss occurred through the natural clearance of infections. 

$$
\mbox{HUMANS} 
\\ \; \\
\left[
\begin{array}{rcl}
\mbox{Infected Tomorrow} &=& \mbox{Infected Today} \;\; \\
&-& \mbox{Infected: Cleared Infection}\\
&+& \mbox{Uninfected: Got Infected}\\
\end{array} \right]
$$

This description of the process thus ignores human demography, including births, deaths, and migration. The model also ignores a large number of other factors, including superinfection, the complex time course of an infection, immunity, and treatment with anti-malarial drugs. (In Ross's day, quinine was expensive and difficult to obtain, but it was sometimes used.) 

We can translate this basic description of a process into a mathematical model.
There are at least four ways of doing this.
The model can be formulated in either discrete or continuous time, and each one could be formulated as a deterministic or stochastic process.

To describe the factors that affect malaria transmission and that determine the prevalence of malaria in human populations over time, we will need to use mathematical models. In the following, we will write down four distinct mathematical equations that follow the basic rules described above: 

1. In Section \@ref(dtsRoss), we present two basic deterministic discrete-time systems. 

3. In Section \@ref(sdtsRoss), we present a stochastic discrete-time system; 

3. In Section \@ref(xdeRoss), we present a deterministic continuous-time system; 

3. In Section \@ref(sxdeRoss), we present a stochastic process in continuous-time; 

With the models in this chapter, we're not trying to delve too deeply into malaria. In this chapter, our goals are to learn the basic elements of different kinds of models, and to develop some basic intuition about the different kinds of models that exist, and how we can think about models as approximations. Each model is implemented as R code^[Footnote about R.] Later, we will start using some R packages that were developed to support robust analytics for malaria policy. Later, we'll worry about modifying the assumptions to ensure that we are dealing with the issues that matter for in malaria policy. 


## Deterministic, Discrete Time Models {#dtsRoss}

In the following, we present a very basic model. Because it is the first model we present, we will be very methodical about the presentation, including sections about computation, analysis, and model verification. We show that the first mdoel is numerically unstable in some cases, so we present another model that is numerically stable. 

### A Basic Model 

Here, present a discrete time deterministic model, one example of a discrete time system (DTS) that was developed to model malaria as a set of coupled difference equations. We will write down the equations last. 

First, we must describe the parts of a model, including the variables, initial conditions, and parameters. As we go, we will also write R code that implements the model and that solves it. We will be adopting some conventions that end up being very useful. So really, this is a lesson about two things. 

**Variables** are quantities that describe the state of a system. These values change over time;  they are the main quantities that we want to compute to understand how the system changes over time. 

In this model, the variables we compute are the fraction of humans and mosquitoes that are infected at each point in time. Since it is a discrete time system, the values of the variables are defined only at integer values of $t.$ 

+ Let $x_t$ be the fraction of people who are infected at time $t,$ and $0 \leq x_t \leq 1.$

+ Let $y_t$ be the fraction of mosquitoes who are infected at time $t,$ $0 \leq y_t \leq 1.$ 

**Initial Conditions** are the values of the variables at a point in time. 

Since the values of our variables in the next time step (at time $t+1$) depend on their values now (at time $t$), we can't really compute anything unless we can say how the process gets started. What are the values of our variables at the beginning of our simulations (usually, at time $t=0$)? 

We set these initial values to be small: 

```{r}
# Initial Conditions at a point in time, as a Named Vector 
xy = c(t=0, x=0.01, y=0.001)
```

This R object `xy` is a *named vector.* The names are invisible, but they attach if we use the function `as.list()` or `data.frame().` When combined with the `with()` function, we can call them by name in context. 

```{r}
with(as.list(xy), x) 
```

We adopt these conventions so that our code closely resembles the equations. 

**Parameters** are quantities that are passed to the model that describe some part of the process. In the model we are developing, these parameters are constant. We would thus call this an *autonomous* system of equations. In other models, we could have parameter values that changes over time, so the system would be called *non-autonomous.*

The parameters describe the processes that are occurring in the population, the fraction of humans that clear an infection each day, and the fraction of infected mosquitoes that die. Unlike variables, parameters are passed to the model.  

  + Let $s$ denote the fraction of people who clear infections after one day; $0 < s < 1.$ 

  + Let $u$ denote the fraction of mosquitoes who die in one day; $0 < u < 1.$ 

  + Let $a$ denote the fraction of mosquitoes who blood feed on a human in a day; $0 < a < 1.$ 

  + Let $m$ denote the number of mosquitoes per human; $m \geq 0.$ 

```{r}
# The parameters, as a list 
par = list(
  s = 1/200, # The fraction of infections that clear each day
  u = 1/12,  # The fraction of mosquitoes that die each day
  a = 1/4,   # The fraction of mosquitoes that blood feed on a human each day
  m = 2      # The number of mosquitoes per human
) 
```

**Equations** describe dynamic changes in the variables over time. In this case, the process is described by a system of coupled difference equations.  

Finally, we put all this together into a mathematical statement that has translated the description of a process, that are describe the process. 

$$\begin{array}{rl}
x_{t+1} &=  x_t - s x_t + m a y_t (1-x_t)  \\ 
y_{t+1} &=  y_t - u y_t + a x_t (1 - y_t) \\ 
\end{array}$$

We can rewrite the equations so that the left hand side is interpreted as *the daily change in the values of the parameters* and the right hand describes those changes: 

$$
\begin{array}{rl}
x_{t+1} - x_t &=  - s x_t + m a y_t (1-x_t)  \\ 
y_{t+1} - y_t &=  - u y_t + a x_t (1 - y_t) \\ 
\end{array}
$$


In this second formulation, there are are four terms: 

+ The fraction of humans who are infected is $x_t$; a fraction $s$ clear infections.
    
+ The fraction of humans who are infected is $1-x_t$; a fraction $m a y_t$ gets infected. 

+ The fraction of mosquitoes who are infected is $y_t$; a fraction $u$ die. 
    
+ The fraction of mosquitoes who are not infected is $1-y_t$; a fraction $a x_t$ gets infected. 

We write a function in R that computes and returns the updated values of the variables. Since we will be developing a lot of functions and models, we adopt a simple naming convention: since it was developed by Ross, we attach the stem `ross`; since this is a discrete time system, we attach the suffix `dts`; we might want to generate other variants, so we append a number. The function is thus called `ross_dts_1.` 

```{r}
# INPUTS
# xy - current variables, as a named vector
# p  - the parameters, as a list
#
# OUTPUTS
# the updated values of the variables, as a named vector
ross_dts_1 = function(xy, p){
  with(as.list(xy), 
    with(p,{
      xn = x - s*x + m*a*y*(1-x) 
      yn = y - u*y + a*x*(1-y) 
      return(c(t=t+1, x=xn, y=yn))
    })
  )
}
```

### Solving Discrete Time Systems

With the R code we developed, we can *solve* the equations, which involves computing the values of the variables iteratively. Since the values of the variables change, we initialize `xy_t` to store the values of computed variables over time. 

```{r}
# xy_t stores the values of the variables
xy_t = xy 
```

To iterate, we must take two steps: one to compute the values, and another to store the values: 

```{r}
# Compute and store the values of the variables  
xy = ross_dts_1(xy, par)
xy_t = rbind(xy_t, xy)
```

Since we initialized the system at time $t=0,$ the following computes the values of the parameters at time $t=1.$ We can take a peak at the values we computed: 

```{r}
# Print 
print(xy) 
```

We can iterate over many time steps, storing the values in columns:

```{r}
# Iterate to compute the values as they change over time 
for(t in 2:40){
  xy = ross_dts_1(xy, par) 
  xy_t = rbind(xy_t, xy) 
} 
```

We can look at the last few values, the values of $t,$ $x$ and $y$ are stored in columns: 

```{r}
print(tail(xy_t, 3)) 
```

### Visualizing

We can now plot out the values over the first 40 days. Since `xy_t` is a named list, we transform it and plot:  

```{r}
with(data.frame(xy_t),{
  plot(t, x, type = "b", ylim = c(0,1), col = "darkgreen", ylab = "x, y", xlab = "Time", pch=15)
  lines(t, y, type = "b", col = "darkorange", pch =19)
})
```

Notice that after 40 days, the values of $x$ and $y$ appear to be approaching some value asymptotically. This is an important feature of these systems, one that we would like to explore a bit more in the following sections. 


We can translate Ross's basic description of a process into a model, but first, we need to start using mathematical symbols and notation to represent the process. The model itself is formulated as a set of coupled difference equations, but we will write down the equations last. To get there, we must learn about the parts of a model: variables, initial conditions, and parameters.  

In the following, we also want to write R code to implement and solve the model. We will be adopting some conventions that end up being very useful. So really, this is a lesson about two things. 

### Computation 

If we want to repeat tasks, we can simply write a wrapper around other functions that expedite the work. In this case, we want to write a function that *solves* the equations (*i.e.* that iteratively computes and stores the values) over some time interval:  

```{r}
solve_ross_dts_1 = function(pars, x0=.01, y0 = 0.001, tmax=100){
   xy = c(t=0, x=x0, y=y0) 
   xy_t = xy 
   for(t in 1:tmax){
     xy = ross_dts_1(xy, pars)
     xy_t = rbind(xy_t, xy)
   }
   return(list(t=xy_t[,1], x=xy_t[,2], y = xy_t[,3], last = xy)) 
}
```

We can write another function that *plots* the equations (*i.e.* that iteratively computes and stores the values) over some time interval:  
 
```{r}
plot_xy = function(xy_t, add_points = FALSE){with(xy_t,{
  llty = "l"
  if(add_points == TRUE) llty = "b"
  plot(t, x, type = llty, ylim = c(0,1), col = "darkgreen", ylab = "x, y", xlab = "Time", pch=15)
  lines(t, y, type = llty, col = "darkorange", pch =19)
})}
```

Now, all the work we did above can be plotted using a single function call:  

```{r}
plot_xy(solve_ross_dts_1(par, tmax=40), add_points=TRUE) 
```

Now, it is easier to use the models in various ways. 

### Steady States 

The fact that our variables asymptotically approach some values over time is an important feature of dynamical systems, so we would like to do some analysis to understand it better.   

In the following, we compute how much the system is changing over time. We can simply iterate once and compare the differences. After iterating 40 times, the differences are very small: 

```{r}
# The last value is still stored as xy; the [-1] omits t
xy[-1] - ross_dts_1(xy, par)[-1]
```

If we iterate another hundred days and check again, the differences have gotten even smaller: 

```{r}
for(i in 41:140){
  xy = ross_dts_1(xy, par)
  xy_t = rbind(xy_t, xy) 
} 
xy[-1] - ross_dts_1(xy, par)[-1]
```

After simulating, the variables reach a steady state, where asymptotically $x_{t+1} = x_t$ and $y_{t+1} = y_t$. 

We can figure out the steady state values are by substituting $x_{t+1} = x_t = x$ and $y_{t+1} = y_t = y$ into the equations above, and then solving for $x$ and $y$. 

$$
\begin{array}{rl}
x &=  x - s x + m a y (1-x)  \\ 
y &=  y - u y + a x (1-y) \\ 
\end{array}
$$

or after cancelling and rearranging: 

$$\begin{array}{rl}
m a y (1-x) &=  s x \\ 
a x (1 - y) &=  u y\\ 
\end{array}$$

The most obvious solution to these equations is $x=y=0,$ which in these models means that there is no malaria. We call it the disease-free steady state. The equilibrium makes some sense: if there are no infected mosquitoes or infected humans in a deterministic model, there can never be any. 

There is another solution where malaria is present. We solve the second equation first: 

$$y = a x / (u + a x).$$ 

We can substitute this for $x$ into the first equation to get: 

$$m a^2 (1-x) =  s (u+ax)$$ 
and now we solve for $x$

$$x = \frac{\textstyle{ma^2 - su}}{\textstyle{ma^2 + sa}}$$
We can write a function to compute this steady state: 

```{r}
# Compute the steady state 
find_eq_dts_a = function(par){with(par,{
  xx = (m*a^2 - s*u)/ (m*a^2 + s*a)
  yy = a*xx/(u+a*xx) 
  c(x=xx,y=yy)
})}
```

### Thresholds 

All our analysis worked out well for the parameter values that we chose, but what if we had picked different parameters? 

There must be some very low level of mosquitoes, for example, where malaria can't reproduce. If we reduce $m$ to $0.005$ and evaluate the expression at the steady state, we get negative values for $x$ and $y$. 

```{r}
par1 = par
par1$m = 0.005
find_eq_dts_a(par1)
```

What happens if we simulate this? (Let's set the initial conditions to reasonably high values) 

```{r}
plot_xy(solve_ross_dts_1(par1, x0 = .5, y0=.3, tmax=1500)) 
```

Our function `find_eq_dts_a` gives us a negative number.

```{r}
find_eq_dts_a(par1)
```

If we look at the equations, it's easy enough to spot the problem. Since $x$ and $y$ must be positive, then it must be true that $$m a^2 > su.$$ We call this a threshold condition.

```{r}
m_crit = with(par, s*u/a^2)
m_crit 
```

If we check, we find that this gives us the disease free equilibrium.  

```{r}
par2 = par
par2$m = m_crit
find_eq_dts_a(par2)
```

We need a better function: 

```{r}
# Compute the steady state 
find_eq_dts_1 = function(par){with(par,{
  xx = ifelse(m*a^2 > s*u, (m*a^2 - s*u)/(m*a^2 + s*a), 0) 
  yy = a*xx/(u+a*xx) 
  c(x=xx,y=yy)
})}
```

```{r}
find_eq_dts_1(par1)
```


### Verification 

We want to get used to double checking everything to avoid inserting mistakes. One way to do this is to find two or more ways of computing the same thing, for verification.

If we've done everything right, we ought to get the same values for the steady states through our analysis and simulation. 
```{r}
xy[-1]
find_eq_dts_1(par) 
```

It's tempting to look at the printout and assume these two numbers are exactly equal. This is the land of computation, so things won't be exact. We can simply sum up the absolute values of the differences: 

```{r}
verify_dts_1 = function(xy, pars){
  sum(abs(xy[-1] - find_eq_dts_1(pars))) 
}
verify_dts_1(xy, par)
```

If we wanted to reduce this to a simple error check, we should pick a tolerance level -- say $10^{-9}$ -- and then just ask if we are closer than that: 

```{r}
check_it_dts_1 = function(xy, pars, tol=1e-9)
{
  verify_dts_1(xy, pars) < tol
}
check_it_dts_1(xy, par)
```

#### Numerical Instability 

There is another problem with the equations. If we set $m$ too high, such that at some point $m a y_t > 1,$ then the whole system eventually crashes:

```{r}
par3 = par
par3$m = 20 
plot_xy(solve_ross_dts_1(par3, x0 = .01, y0=.001, tmax=20)) 
```

In discrete time formulations, we must be very careful to ensure that we have formulated a proper model. How can we fix this problem? We have to go back and rethink the way we formulated our model. How does the probability of getting infected scale with the number of infective bites?

### An Improved Model {.tabset .tabset-fade .tabset-pills}

#### Exposure 

One way to do this is to say that the *expected* number of bites would follow a Poisson distribution with mean $may_t,$ so that the fraction getting infected is the zero term from a Poisson:

$$1 - e^{-m a y_t}$$ 

Now, our equations are the following:

$$\begin{array}{rl}
x_{t+1} &=  x_t - s x_t + (1-e^{m a y_t}) (1-x_t)  \\ 
y_{t+1} &=  y_t - u y_t + a x_t (1 - y_t) \\ 
\end{array}$$

#### Steady States

Now, if we want to compute the steady state, we're stuck with the problem of solving this:  

$$(1-e^{-m a^2 x/(u + a x)}) (1-x) = sx$$ 
It's surprisingly easy to write down equations, like this one, that we can't solve with pencil and paper. We can still find a way of computing the steady state, but we have to write R code that solves for $x$ numerically. 

```{r}
find_eq_dts_2 = function(pars){with(pars,{
   f_xx = function(x, pp){with(pp,{
     xx = (1 - exp(-m*a^2*x/(u+a*x)))*(1-x) - s*x
     y = a*xx/(u+a*xx)
     yy = u*y + a*xx*(1-y) 
     return(xx^2 + yy^2)
   })}
   xx = optimize(f_xx, c(0,1), pp=pars)$min
   yy = a*xx/(u+a*xx) 
   c(xx, yy)
})}
```

The new equilibrium is at:

```{r}
find_eq_dts_2(par3)
```

#### Workflows 

We can just as easily write the code to numerically solve the discrete time system: 

```{r}
dts_xy_2 = function(xy, p){with(as.list(xy), with(p,{
  xn = x - s*x + (1-exp(-m*a*y))*(1-x) 
  yn = y - u*y + a*x*(1-y) 
  t=t+1
  return(c(t=t, x=xn, y=yn))
}))}
```

Once again, we can wrap a function around the solver so that it's easier to use the code: 

```{r}
solve_dts_xy_2 = function(pars, x0=.01, y0 = 0.001, tmax=100){
   xy = c(t=0, x=x0, y=y0) 
   xy_t = xy 
   for(t in 1:tmax){
     xy = dts_xy_2(xy, pars)
     xy_t = rbind(xy_t, xy)
   }
   return(list(t=xy_t[,1], x=xy_t[,2], y = xy_t[,3], last = xy)) 
}
```


Now, we can visualize the output and see that we have fixed our stability problem. 

```{r}
plot_xy(solve_dts_xy_2(par3, x0 = .01, y0=.001, tmax=20)) 
```

#### Verification  

```{r}
find_eq_dts_2(par3)
```


```{r}
solve_dts_xy_2(par3, x0=.1, y0=.05,tmax=300)$last[-1]
```

Once again, we want to ensure that our code does not have any mistakes, so we write a function to verify our results. 

```{r}
verify_dts_2 = function(pars, x0 = .1, y0=.05, tmax=200){
  xyt = solve_dts_xy_2(pars, x0=x0, y0=y0, tmax=tmax)
  sum(abs(xyt$last[-1] - find_eq_dts_2(pars))) 
}
```

```{r}
verify_dts_2(par3, tmax=300)
```

A function to check that it is accurate to some level of tolerance, but the numerical precision is mismatched, somehow.   

```{r}
check_it_dts_2 = function(pars, x0 = .1, y0=.05, tmax=200, tol=1e-5)
{
  verify_dts_2(pars, x0, y0, tmax) < tol
}
check_it_dts_2(par3, tmax=200)
```


## Discrete Time, Stochastic {#sdtsRoss}

The world is stochastic. 

## Continuous Time, Deterministic {#xdeRoss}

Here, we present a continuous time, deterministic model. It is homologous to Ross's 2nd model [@RossR1911Nature], after renaming the parameters. To deal with these equations, you need a background in calculus. 

### Variables and Initial Conditions

Once again, variables are quantities that we compute and that change over time. In this model, the variables we compute are the fraction of humans and mosquitoes that are infected at each point in time. Since it is a continuous time system, the values of the variables are defined for all values of $t.$ 

+ Let $x(t)$ be the fraction of people who are infected at time $t,$ and $0 \leq x(t) \leq 1.$

+ Let $y(t)$ be the fraction of mosquitoes who are infected at time $t,$ $0 \leq y(t) \leq 1.$ 

As before, we will need to define initial conditions. 

### Parameters 

The parameters describe the processes that are occurring in the population, the fraction of humans that clear an infection each day, and the fraction of infected mosquitoes that die. Unlike variables, parameters are passed to the model.  

  + Let $r$ denote the fraction of people who clear infections after one day; $0 < r < 1.$ 

  + Let $g$ denote the fraction of mosquitoes who die in one day; $0 < g < 1.$ 

  + Let $a$ denote the fraction of mosquitoes who blood feed on a human in a day; $0 < a < 1.$ 

  + Let $m$ denote the number of mosquitoes per human; $m \geq 0.$ 

```{r}
# The Parameters, as a Named Vector
ross_xde_par = list(
  r = 1/200, # The fraction of infections that clear each day
  g = 1/12,  # The fraction of mosquitoes that die each day
  a = 1/4,   # The fraction of mosquitoes that blood feed on a human each day
  m = 2      # The number of mosquitoes per human
) 
```

### Equations

Finally, we put all this together into a mathematical statement that has translated the description of a process. There are four terms: 

+ The fraction of humans who are infected is $x$; infections clear at the rate $r.$ 
    
+ The fraction of mosquitoes who are infected is $y$; mosquitoes die at the rate $g.$ 
    
+ The fraction of humans who are infected is $1-x$; infections occur at the rate $m a y.$ 
    
+ The fraction of mosquitoes who are not infected is $1-y$; infections occur at the rate $a x.$ 

$$ 
\begin{array}{rl}
dx/dt &= may(1-z) - r x\\
dy/dt &= ax(1-y) - g y \\
\end{array}
$$ 

```{r}
ross_xde = function(t, y, params){
  with(params, with(as.list(y),{
    
  dxdt = m*a*y*(1-x) - r*x
  dydt = a*x*(1-y) - g*y
  
  return(list(c(dxdt, dydt)))
}))}
```

### Solving

We use the R package ***deSolve***

```{r}
library(deSolve)
```

The wrapper: 

```{r}
solve_ross_xde = function(pars, x0=.01, y0=0.001, tmax=50, dt=1){
  tms = seq(0, tmax, by = dt)
  xy0 = c(x=x0, y=y0)
  data.frame(ode(xy0, tms, ross_xde, pars)) 
}
```

It works. 

```{r}
deout <- solve_ross_xde(ross_xde_par)
```

Plot

```{r}
with(deout, {
  plot(time, x, type = "l", col = "darkgreen", ylim = c(0,1), ylab = c("x, y"))
  lines(time, y, col = "darkorange")
})
```


These differential equations require  

### Verification  

We set $dx/dt = dy/dt=0$ 

$$ 
\begin{array}{rl}
0 &= may(1-x) - r x\\
0 &= ax(1-y) - g y \\
\end{array}
$$ 
Solve the second equation for $y$ 

$$y = ax/(g+ax)$$

Substitute back into the first equation: 

$$ma^2 (1-x) = r(g+ax)$$ 
and solve. 

$$x = \frac{\textstyle{m a^2 - rg}}{\textstyle{m a^2 + ra}}$$ 

Noting that $m a^2 > rg$ must be a threshold condition, we write a function to compute the steady state using the formula we just derived: 

```{r}
find_eq_xde_1 = function(pars){with(pars,{
  xx = ifelse(m*a^2 > r*g, (m*a^2 - r*g)/(m*a^2 + r*a), 0) 
  yy = a*xx/(g+a*xx)
  c(x=xx, y=yy)
})}
```

```{r}
find_eq_xde_1(ross_xde_par)
```

We check it against the other way, which involves running the system for a very long time.

```{r}
de_eq <- solve_ross_xde(ross_xde_par, tmax=500, dt=5)
with(de_eq, c(x=tail(x,1), y=tail(y,1))) 
```



## Continuous Time, Stochastic {#sxdeRoss}

The world is stochastic. 

### Deterministic  

### Stochastic  

We want to to introduce a mathematical model that is a good starting point. None of the models presented in the previous chapter are suitable, largely because the variables in those models were proportions. The models we will use are almost identical, but the variables are densities. 

## Comparing Models

## Notes

### Why use densities? 

To show why we use densities, we present a simple example. If we write down an equation describing changes in the density of infected humans, $X$, in a population with total human population density $H$. We let $V$ denote vectorial capacity, and $b$ the fraction of infective bites that cause an infection, and we assume the force of infection is $bVX/H$. The dynamics of infection are described by this simple equation:  

$$\frac{dX}{dt} = bV\frac{X}{H}(H-X)-rX$$ 
In this equation, prevalence is $x = X/H.$ Following through with the change in variables, we can write down the equation for the change in prevalence: 

$$\frac{dx}{dt} = \frac{1}{H^2} \left(H \frac{dX}{dt} - X \frac{dH}{dt} \right)$$

and with some rearranging, we get:

$$\frac{dx}{dt} = bVx(1-x)-rx -x \frac{dH}{dt}$$ 

The second equation is as simple as the first only if $dH/dt=0$. Since we will want to deal with dynamical changes in host populations, we will avoid formulating base models that have proportions. 


