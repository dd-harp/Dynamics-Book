[["malaria-population-dynamics.html", "1 Malaria Population Dynamics", " 1 Malaria Population Dynamics We start by introducing a Ross-Macdonald model [1]. This particular system of delay differential equations traces back to a 1982 book chapter written by Joan Aron and Robert May [2]. We think it’s a good starting point. We chose it because it is extensible. The variables in this model represent population densities. The variables are used to compute statistics like prevalence, a proportion. The variables in most other versions of the Ross-Macdonald are proportions. In building models, we would sometimes like to change the total number of hosts (i.e. the denominators), but if the variables in equations described proportions, they are much more difficult to modify. We chose it because we can bypass a lengthy discussion of the limitations of the Ross-Macdonald model, as it was presented by Macdonald. While Macdonald’s analysis and formulas are familiar, they overlooked the role of mosquito ecology. This model lets us bypass a lengthy discussion about history and the way it skews opinions. Our formula for vectorial capacity is consistent with the original, but our analysis includes effects on mosquito ecology. We chose it because it is realistic. Most Ross-Macdonald equations are autonomous (time is never used in computing derivatives), but these equations are already non-autonomous (i.e. time drives a seasonal pattern). We know that malaria transmission dynamics are forced by exogenous variables (e.g., weather), so why start by avoiding that fact? We recommend that everyone reads this chapter, even those who are familiar with the Ross-Macdonald model. In writing the equations, we introduced some concepts and conventions that became important for the software design. References "],["aron-and-mays-equations.html", "1.1 Aron and May’s Equations", " 1.1 Aron and May’s Equations The simplest quantitative description of malaria dynamics tracks the number of infected and infectious mosquitoes and the number of infected and infectious humans. To develop systems of equations, we assign names to variables that represent these quantities: the number of infected and infectious people is denoted \\(X(t)\\) (out of \\(H\\) total); the number of mosquitoes is \\(M(t)\\); the number of infected mosquitoes is \\(Y(t)\\) (out of \\(M(t)\\) total); and the number of infectious mosquitoes is denoted \\(Z(t)\\) (out of \\(M(t)\\) total). In dynamical systems, we ask how the variables (i.e. \\(M\\), \\(Y\\), \\(Z\\), and \\(X\\)) change over time. For our first equation, we start with adult, female mosquito populations. (It is tiresome to repeat adult, female each time, and we’re ignoring male mosquitoes at this point anyway, so mosquito hereafter means adult, female mosquito, unless we say otherwise.) The number of mosquitoes is changing as new adults emerge from aquatic habitats or die. 1.1.1 Mosquito Ecology To model changes in \\(M\\), we assume the following: mosquitoes emerge from aquatic habitats at the rate of \\(\\Lambda(t)\\) adults, per day; mosquitoes die at a constant rate, \\(g\\). This is equivalent to assuming that the mosquito lifespan is exponentially distributed with a mean \\(1/g\\). The fraction surviving one day is \\(e^{-g}\\). Our first equation describes changes in the number of mosquitoes: \\[\\begin{equation} \\frac{dM}{dt} = \\Lambda(t) - g M \\end{equation}\\] 1.1.2 Blood Fed Mosquitoes At this point, we will take a detour and define a variable describing the density of mosquitoes that have blood fed at least once, \\(V\\). After blood feeding, a mosquito is either gravid or parous, meaning its ovaries are distended from laying an egg batch. We do this, in part, because the fraction of mosquitoes that are parous is routinely collected, and because it gives us a chance to focus on blood feeding. To describe blood feeding, we assume the following: mosquitoes blood feed at the rate \\(f\\), per mosquito, per day; in this model, this implies that the waiting time to a blood meal is \\(1/f\\) days. a fraction of all mosquito blood meals, \\(q\\), is taken on humans; we call this the human fraction the human blood feeding rate is the product of these two parameters, \\(fq\\), which is defined as the number of human blood meals, per mosquito, per day. The number of human blood meals by a population of vector mosquitoes, per person, per day is called the human biting rate (HBR). In this model, HBR is given by a formula: \\[\\mbox{HBR} = \\frac{fqM}{H}\\] Later, we discuss the correspondence between the HBR in models and data. \\[\\begin{equation} \\frac{dV}{dt} = f q (M-V) - g V \\end{equation}\\] We won’t use \\(V\\) to describe the dynamics of infection, but we might find it useful to understand how parity changes in mosquito populations. 1.1.3 Infected Mosquitoes Mosquitoes become infected after blood feeding on an infectious human. To model changes in \\(Y\\), we extend the model of blood feeding to include infection. We need to know what fraction of blood meals end up infecting a mosquito that has not already been infected. To model changes in \\(Y\\), we need to describe infection rates. We assume the following: a fraction of human blood meals, infects mosquitoes. We call this quantity net infectiousness (NI) and (for reasons that we will discuss in a moment), we give it a name, \\(\\kappa\\): \\[\\kappa(t) = c \\frac{X(t)}{H}\\] infected mosquitoes die at the same rate as uninfected mosquitoes. We can now write down our second equation describing changes in the number of infected mosquitoes: \\[\\begin{equation} \\frac{dY}{dt} = f q \\kappa (M-Y) -g Y \\end{equation}\\] 1.1.4 Infectious Mosquitoes To become infectious, a mosquito has to become infected and then survive through the extrinsic incubation period (EIP). We assume: mosquitoes become infectious after a fixed delay, \\(\\tau\\) days, called the EIP. The fraction of mosquitoes that survive through the EIP is \\(e^{-g \\tau}\\). infectious mosquitoes die at the same rate as other mosquitoes. For a mosquito to become infectious, it must have become infected \\(\\tau\\) days ago and survived through \\(\\tau\\) days with probability \\(e^{-g\\tau}\\). To write this in equations, we use a subscripted \\(\\tau\\) to denote the value of a variable (\\(M\\), \\(Y\\) or \\(X\\)) or term (\\(\\kappa\\)) at time \\(t-\\tau\\). For example \\(X_\\tau\\) is the number of people who were infected and infecious at time \\(t-\\tau\\), and \\(M_\\tau\\) is the number of mosquitoes at time \\(t-\\tau\\). The number of infectious mosquitoes that are added to the population at a point in time includes all the mosquitoes that became infected at time \\(t-\\tau\\) and survived the EIP. This is our third equation describing changes in the number of infectious mosquitoes: \\[\\begin{equation} \\frac{dZ}{dt} = f q \\kappa_\\tau (M_\\tau-Y_\\tau) e^{-g\\tau} -g Z \\end{equation}\\] Here, \\(Z\\) represents the number of mosquitoes with sporozoites in their salivary glands. The fraction of mosquitoes with sporozoites in their salivary glands has been called the sporozoite rate (SR), which in our notation is \\[ z = \\frac{Z}{M}\\] The number of bites by vector mosquitoes, per person, per day is called the entomological inoculation rate (EIR). It is defined as the product of the HBR and the SR: \\[\\mbox{EIR} = \\mbox{SR} \\times \\mbox{HBR}\\] In our notation, the EIR is: \\[\\mbox{EIR} = z \\frac{fqM}{H} = \\frac{fqZ}{H}\\] As with the HBR, we would like to know how to connect estiamted values of the EIR to our formulas. Since that’s really complicated, we’ve spent a lot of time in the following sections discussing it. 1.1.5 Infected Humans Humans become infected after being bitten by an infectious mosquito. We assume the following: A fraction \\(b\\) of all bites by infectious mosquitoes cause an infection. The hazard rate for infection, also called the force of infection (FoI) and denoted \\(h\\) is \\(b \\times\\) EIR: \\[h = fqb \\frac{Z}{H}\\] Infections clear at the rate \\(r\\), per infection, per day (the average time to clear is \\(1/r\\) days), and after clearing an infection a person becomes susceptible to infection again. We can now write down our fourth equation describing changes in the number of infected humans: \\[\\begin{equation} \\frac{dX}{dt} = h (H-X) - r X \\end{equation}\\] 1.1.6 …as a System While we presented these equations one at a time, they work as a system. To see it all at once, we write it here as a system with four equations and two terms: \\[\\begin{equation} \\begin{array}{rl} \\frac{dM}{dt} &amp;= \\Lambda(t) - g M \\\\ \\frac{dY}{dt} &amp;= fq\\kappa(M-Y) - g Y \\\\ \\frac{dZ}{dt} &amp;= fq\\kappa_\\tau(M_\\tau-Y_\\tau)e^{-g\\tau} - g Z \\\\ \\frac{dX}{dt} &amp;= h (H-X) - rX \\\\ \\\\ \\hline \\\\ \\kappa &amp;= c \\frac{X(t)}{H} \\\\ h &amp;= b fq \\frac{Z(t)}{H} \\\\ \\end{array} \\end{equation}\\] A diagram of the a version of the Ross-Macdonald model, using equations from Aron and May [2] These equations describe processes in three domains (Figure 2.1): adult mosquito ecology (\\(M\\), and perhaps \\(V\\)); parasite infection dynamics in mosquito populations (\\(Y\\) and \\(Z\\)); parasite infection dynamics in human populations (\\(X\\)). The equations describing parasite infections in mosquito populations also include the variable \\(M\\), so the mosquito infection dynamics are coupled to the mosquito population dynamics. The way we’ve written the equations, each compartment has an input term (i.e., \\(\\Lambda\\), \\(\\kappa\\), or \\(h\\)) that depends on something else. We’ve passed \\(\\Lambda\\) as a parameter. For the infection dynamics, the terms \\(\\kappa\\) and \\(h\\) couple two separate systems. For adult mosquito dynamics, emergence is passed to the model as a parameters. There are, of course, more compact ways of writing these equations. We have written the equations this way to emphasize a few things. First, the terms make it clear exactly how the equations in one domain are connected to another. Second, if we wanted to start changing some of the assumptions, these terms help to isolate the parts we might like to change. By writing the equations in this modularized form, we can start to understand how we might be able to write software that would allow us to represent mosquito infection dynamics with different systems of equations. The next step is to find solutions. References "],["solutions.html", "1.2 Solutions", " 1.2 Solutions What does a solution to these equations look like? Solutions to these equations are values of the variables over time \\(\\left( M(t), Y(t), Z(t), X(t) \\right)\\) that satisfy the system of four equations described above. We call these solutions orbits. To put it another way, if we took the derivatives of the orbits for any variable at any point in time using the basic definition \\[\\lim_{h\\rightarrow 0} \\frac{x(t+h)-x(t)}{h},\\] and then we used the values of the variables at time \\(t\\) to compute \\(dM/dt\\), \\(dY/dt\\), \\(dZ/dt\\), and \\(dX/dt\\) (i.e., using the formulas on the previous page), we would get the same values. It is important that these orbits are unique: after specifying the initial values of the variables, there is one and only one set of orbits that solves the equations. When we solve the equations, we usually produce solutions from a starting point into a future, but the orbits are defined for all time – \\(i.e.\\) the process implies the existence of solutions far back into the past. These are deterministic equations, after all. As written, the equations do not define a model. Instead, the equations define a process or a model family. A model is something that can produce orbits. A model is defined only after assigning specific values to the parameters. Informally, we will often slip and use the “model” to describe a model family. It’s easy to slip up, and sometimes we can get by with being sloppy, but we need to remember the distinction. When we say that the software is modular, we mean that it is easy to swap out one model family for another. To find solutions of equations we use an R software package called deSolve. Because of the delay for the EIP, these are called delay differential equations, which are handled using a function called dede. An important step in solving delay differential equations is a function lagvalue() that computes and returns the values of variables at a time lag, \\(\\ell\\). In these equations, the lag is set by the EIP, \\(\\tau\\), so we must evaluate lagvalue(t-tau). In solving ordinary differential equations, we must pass initial conditions. To solve a delay differential equations, we must specify the initial conditions for the interval \\([-\\ell, t_0)\\), where \\(t_0\\) is the point in time when we start computing solutions. In these equations, since the equation for \\(dZ/dt\\) looks back \\(\\tau\\) units, we must specify values of \\(M(t)\\), \\(Y(t)\\), and \\(X(t)\\) for all values of \\(t \\in [-\\tau, t_0)\\). This forces an awkward choice, since we don’t know the solutions backwards in time, but would need to know those solutions to use them. What is typically done – and we’ve done it here – is to specify a constant set of initial values and moving on. Doing this introduces a little numerical slop. By slop, we mean that these values are not what we would get if we ran the equations backwards in time. In these equations, it won’t affect our analysis most of the time, so we’re happy to acknowledge this little problem and find ways around it. It’s a little thing, but we should never forget it, because we might find that it is affecting our analysis at some point. With deSolve, solving differential equations is not difficult – it just involves following a few steps. In the following, we walk through these steps: Write a function that computes the derivatives; Define initial conditions; Define the values of the parameters; Define a mesh on time; Call a function that solves the equations, such as dede for delay differential equations. Many users will find that reading this code is like learning how to compute \\(\\sqrt{2}\\). If so, feel free to learn it once and then skip it. 1.2.1 Derivatives The first step is to write down the equations to compute the derivatives. The solver expects a function with three required arguments (in this order): t is time y is the list of variables params is a set of parameters The derivatives are computed and returned in the same order as ‘y’ in a list. To make code that is easy to read, we make params as a list with parameter names (see below), so that inside the function with(params,{...}), the parameter names are visible. dAronMay = function(t, y, params){with(params,{ # Variables if(t&lt;=tau) ylag&lt;-y0 else ylag &lt;- lagvalue(t-tau) M=y[1]; M_tau = ylag[1] Y=y[2]; Y_tau = ylag[2]; Z=y[3]; X=y[4]; X_tau = ylag[4] # Terms kappa = c*X/H; kappa_tau = c*X_tau/H h = b*f*q*Z/H # Dynamics dM = Lambda(t) - g*M dY = f*q*kappa*(M-Y) -g*Y dZ = f*q*kappa_tau*(M_tau-Y_tau)*exp(-g*tau) -g*Z dX = h*(H-X)-r*X return(list(c(dM, dY, dZ, dX))) })} 1.2.2 Initial Values To run the model, we must supply initial values. If you were writing code yourself, it would be important to remember that the initial values and the return value for the derivatives must occur in the same order. A useful convention in {R} is to pass the initial values as a named list. Later, we can turn the outputs into a data frame, and then we can retrieve the variables by name. y0= c(M=60, Y=0, Z=0, X=1) The object y0 is a named list – the names are attached but invisible. y0 ## M Y Z X ## 60 0 0 1 When we turn it into a list, with as.list, the names are attached to the values: as.list(y0)$M ## [1] 60 If we use with, we create an environment where we can simply use the names: with(as.list(y0), { M }) ## [1] 60 1.2.3 Parameter Values We pass the parameters as a list. It might seem like overkill, but we have written a function makeParams() that takes default values and generates a list. This makes it easy to generate a new set of parameter values with alternative values, and it also helps us to write and pass function \\(\\Lambda(t)\\) with parameters we like. By passing the parameter as a list, the parameter values are available to the function dAronMay when we use with(params, {}). Note that we have also attached the initial values of the variables as a parameter set, which are the return values for lagvalue(t) when t&lt;0. makeParams = function(y0, g=1/12, f=1/2.5, q=0.95, c=0.15, b=0.55, r=1/200, H=1000, m=.05, ss=1, tau=10 ){ ss = min(1,max(0, ss)) return(list(y0=y0,g=g,f=f,q=q,c=c,H=H,tau=tau,b=b,r=r, Lambda = function(t){m*H*(1 + ss*sin(2*pi*t/365))})) } params = makeParams(y0) To make it absolutely clear, we are assuming: \\(g=1/12\\): mosquitoes live about \\(12\\) days, on average \\(f=1/2.5\\): mosquitoes feed every 2.5 days, on average \\(q=0.95\\): the human fraction is 95%; mosquitoes feed on humans 95% of the time \\(c=0.15\\): about 15% of bites on infectious humans infect a mosquito \\(b=0.55\\): about 55% of bites by infective mosquitoes cause an infection \\(r=1/200\\): human infections last about \\(200\\) days, on average \\(H=1000\\): we’re simulating transmission in a population of a thousand humans \\(\\tau=10\\): the extrinsic incubation period is about 10 days For emergence, we tune the average value using \\(m\\) and it is scaled to \\(H\\): The parameter \\(m\\) in the function above has been set to \\(0.05\\) by default. The parameter \\(ss\\) affects the amplitude of the fluctuations. We force it to take on values between 0 and 1. Emergence is modeled as a sinusoidal function with a yearly cycle. \\[\\Lambda(t) = m H \\left(1 + \\sin \\left(\\frac{2\\pi t}{365}\\right)\\right)\\] "],["time-mesh.html", "1.3 Time Mesh", " 1.3 Time Mesh We define a mesh over time – the points in time when we would like to know the values of the variables: tt = seq(0,5*365, by=5) 1.3.1 Solving This code solves the equations: require(deSolve) yout &lt;- dede(y=y0, times=tt, func=dAronMay, parms=params) 1.3.2 Visualizing We write a function so that we can plot things easily: plotTS_AronMay = function(yout){with(data.frame(yout),{ par(mfrow = c(2,1)) plot(time/365, M, type = &quot;l&quot;, col = &quot;blue&quot;, xlab = &quot;Time (in Years)&quot;, ylab = &quot;Mosquito Density&quot;, main = &quot;Mosquitoes&quot;) lines(time/365, Y, col = &quot;purple&quot;) lines(time/365, Z, col = &quot;red&quot;) plot(time/365, X, ylim = c(0,1000), type = &quot;l&quot;, xlab = &quot;Time (in Years)&quot;, ylab = &quot;# Infected Humans&quot;, main = &quot;Humans&quot;) })} This code plots the outputs: plotTS_AronMay(yout) "],["steady-states.html", "1.4 Steady States", " 1.4 Steady States To analyze this system, we first set the parameter ss=1, so that we can look at the system without seasonality. Without seasonality, the system is actually autonomous. We do this, in part, because the resulting system is easier to understand, which helps us develop intuition that can be applied (albeit with caution) to more complex systems. To be clear, we are dealing with this system: \\[\\begin{equation} \\begin{array}{rl} \\frac{dM}{dt} &amp;= \\Lambda - g M \\\\ \\frac{dY}{dt} &amp;= fq\\kappa(M-Y) - g Y \\\\ \\frac{dZ}{dt} &amp;= fq\\kappa_\\tau(M_\\tau-Y_\\tau)e^{-g\\tau} - g Z \\\\ \\frac{dX}{dt} &amp;= h (H-X) - rX \\\\ \\\\ \\hline \\\\ \\kappa &amp;= c \\frac{X(t)}{H} \\\\ h &amp;= b fq \\frac{Z(t)}{H} \\\\ \\end{array} \\end{equation}\\] The first thing to note is that \\(M\\) affects \\(Y\\) and \\(Z\\), which affect \\(X\\); but \\(M\\) is not affected by \\(Y\\) or \\(Z\\). Mosquito population density is an exogenous factor affecting malaria population dynamics. We can thus treat it separately: \\[\\begin{equation} \\frac{dM}{dt} = \\Lambda - g M \\end{equation}\\] Since emergence rates are steady, mosquito population density reaches a steady state when \\(dM/dt=0\\), which occurs at: \\[\\begin{equation} \\bar M = \\frac{\\Lambda}{g} \\end{equation}\\] Next, we note that at a steady state, the delayed values of variables and terms don’t change, so from \\(dY/dt\\), we get: \\[\\begin{equation} g \\bar Y = fq\\kappa(\\bar M- \\bar Y) \\end{equation}\\] If we substitute the formula for \\(\\bar M\\) and solve for \\(\\bar Y\\), we get: \\[\\begin{equation} \\bar Y = \\frac{fq\\kappa}{g + fq\\kappa} \\frac{\\Lambda}{g} \\end{equation}\\] and we substitute the formula for \\(g \\bar Y\\) into \\(dZ/dt\\) to get: \\[\\begin{equation} \\bar Y e^{-g\\tau} = \\bar Z \\end{equation}\\] or equivalently: \\[\\begin{equation} \\bar Z = \\frac{f q \\kappa}{g + fq \\kappa} \\frac{\\Lambda}{g} e^{-g\\tau} \\end{equation}\\] It is a little thing, but the quantity \\[S = \\frac{fq}{g}\\] is the number of bloodmeals a mosquito would take over its lifespan. At the steady state, \\[\\mbox{EIR} = fq \\frac{\\bar Z}{H},\\] but if we rearrange the terms a bit, we get: \\[\\begin{equation} \\mbox{EIR} = fq \\frac{\\bar Z}{H} = \\frac{\\Lambda}{H} S^2 e^{-g\\tau} \\frac{\\kappa}{1 + S \\kappa} \\end{equation}\\] For the moment, we let \\[V = \\frac{\\Lambda}{H} S^2 e^{-g\\tau}.\\] It is the formula for vectorial capacity. We can thus write: \\[\\begin{equation} \\mbox{EIR} = V \\kappa \\frac{1}{1 + S \\kappa} \\end{equation}\\] At the steady state, \\[\\kappa = c \\frac{X}{H}.\\] If we substitute this into the expression for the EIR, we get: \\[\\begin{equation} \\mbox{EIR} = c V X\\frac{1}{H + c S X} \\end{equation}\\] Now, we’re going to define \\[R_0 = \\frac{bcV}{r}.\\] If we plug this into \\(dX/dt\\) we get an expression that involves only \\(X\\) \\[\\frac{1}{r} \\frac{dX}{dt} = X \\left( R_0 \\frac{H-X}{H + cSX} - 1\\right)\\] Since \\(X\\) is the density of infected humans, it can never be a negative number and it is always smaller than \\(H\\): we write \\(X \\in [0, H]\\). When \\(X\\) is very close to \\(0\\), then \\[\\lim_{X \\rightarrow 0} \\frac{H-X}{H + cSX} = 1\\] In fact, \\[\\frac{H-X}{H + cSX} \\lapprox 1\\] \\[\\frac{1}{r} \\frac{dX}{dt} \\approx X \\left( R_0 - 1\\right)\\] It follows that if \\(R_0 &gt;1\\), then \\(X\\) will tend to increase. We let \\[x = \\frac{X}{H}\\] denote the prevalence of infection, or the fraction of people who are infected. Since \\(H\\) is constant, it is a simple matter to change the variables, and can write: In this equation, if \\(R_0 &gt; 1\\), then there is a steady state at: \\[ x= \\frac{R_0 -1}{R_0 + c S}\\] and if \\(R_0&lt;1\\), then there is a stable steady state at \\(\\bar x=0\\). "],["stable-orbits.html", "1.5 Stable Orbits", " 1.5 Stable Orbits The first point we want to make is about the compareTS_AronMay = function(yout1, yout2){ dta1 = data.frame(yout1) dta2 = data.frame(yout2) par(mfrow = c(2,2)) with(dta1,plot(time/365, M, type = &quot;l&quot;, col = &quot;blue&quot;, xlab = &quot;Time (in Years)&quot;, ylab = &quot;Mosquito Density&quot;, main = &quot;Mosquitoes&quot;)) with(dta2, lines(time/365, M, col = &quot;blue&quot;, lty=2)) with(dta1,plot(time/365, Y, type = &quot;l&quot;, col = &quot;purple&quot;, xlab = &quot;Time (in Years)&quot;, ylab = &quot;Infected Mosquito Density&quot;, main = &quot;Mosquitoes&quot;)) with(dta2, lines(time/365, Y, col = &quot;purple&quot;, lty=2)) with(dta1,plot(time/365, Z, type = &quot;l&quot;, col = &quot;red&quot;, xlab = &quot;Time (in Years)&quot;, ylab = &quot;Infectious Mosquito Density&quot;, main = &quot;Mosquitoes&quot;)) with(dta2, lines(time/365, Z, col = &quot;red&quot;, lty=2)) with(dta1,plot(time/365, X, ylim = c(0,1000), type = &quot;l&quot;, xlab = &quot;Time (in Years)&quot;, ylab = &quot;# Infected Humans&quot;, main = &quot;Humans&quot;)) with(dta2, lines(time/365, X, lty=2)) } y1 = c(M=1100, Y=100, Z=100, X=100) params1 = makeParams(y1) yout1 &lt;- dede(y=y1, times=tt, func=dAronMay, parms=params1) compareTS_AronMay(yout, yout1) The idea of stability and basins of attraction. Stable states Stable orbits Long-term average vs steady states "],["the-basic-reproductive-number.html", "1.6 The Basic Reproductive Number", " 1.6 The Basic Reproductive Number "],["discussion.html", "1.7 Discussion", " 1.7 Discussion "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
